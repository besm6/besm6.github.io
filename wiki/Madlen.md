# Описание автокода Madlen

(Глава III из книги Салтыков, Макаренко "Программирование на языке Фортран")

## 1. Введение

Автокод Madlen используется в мониторной системе «Дубна» как самостоятельный язык
программирования нижнего уровня и как промежуочный язык при трансляции подпрограмм с Фортрана.
При трансляции алгольных процедур (написанных
на Алголе-ГДР [39]), выхода на Madlen не происходит,
однако пользователь имеет возможность получить рас­печатку
текста транслированной процедуры в виде,
сходном с автокодной записью. При необходимости
можно получить автокодный текст транслированной
алгольной процедуры путем обратной трансляции ее
с языка загрузки на автокод (см. 1261).

Часть пакета задачи, написанная на автокоде,
оформляется как отдельная'подпрограмма или несколько
подпрограмм и транслируется независимо от других
подпрограмм. Если автокодная подпрограмма оформ­лена
по определенным правилам, то она может быть
использована наравне с фортранными и алгольными
подпрограммами (см. § 14).

Текст подпрограммы на автокоде обладает достаточ­ной
наглядностью, что позволяет, в частности, с успе­хом
анализировать подпрограммы, написанные другими авторами.

Основу автокодной подпрограммы составляют автокодные
команды, представляющие собой символическую
запись машиппых команд. Каждая автокодная команда,
как правило, транслируется в одну машинную команду
(исключения описаны в § 15). То обстоятельство, что
Madlen является промежуточным языком при тран­сляции
с Фортрана, естественным образом отразилось
на его структуре. Например, любой невыполняемый
(декларативный) оператор Фортрана имеет автокодный аналог.

Транслятор с автокода выдает удобную для пользо­вателя
диагностику ошибок, имеет аппарат редакти­рования,
позволяющий получать автокодный текст
в виде, удобном для чтения, независимо от способа его
пробивки. Все это в сочетании с высокой скоростью тран­сляции
(200 операторов в секунду) делает автокод
Madlen удобным и эффективным средством програм­мирования
при решении задач, требующих максималь­ного использования специфики БЭСМ-6.

## 2. Операторы автокода

Подпрограмма на автокоде состоит из операторов,
каждый из которых располагается на отдельной перфо­карте.
При необходимости запись некоторых опера­торов
может быть продолжена на последующие пер­фокарты.
Отметим, что в некоторых руководствах по автокоду
наравне с термином «оператор» используется термин «инструкция».

Формат автокодного оператора подобен формату
машинной команды. Это означает, что отдельные его
составные части боответствуют индекс-регистру, коду
операции и адресной части машинной команды. Кроме
того, всегда можно обозначить адрес ячейки, в которой
находится данная команда, а также поставить при­знак
того, что данная команда является левой, т. е.
занимает 24 старших разряда машинного слова. По­скольку
для записи каждой части автокодного опера­тора
нет специально выделенных колонок перфокарты,
эти части отделяются друг от друга специальными
разделителями (запятая, двоеточие, точка).

Любой автокодный оператор может быть расположен
в произвольных колонках перфокарты с 2-й по 42-ю
включительно. Некоторые операторы имеют «длинную»
структуру и могут располагаться по 72-ю колонку включительно.
Колонки с 73-й по 80-ю всегда отно­ятся к комментарию.

При дальнейшем изложении мы будем использовать
запись понятий, не являющихся элементами данного
языка, с помощью угловых скобок < >.

Большинство операторов автокода шаб1еп можно за­
писать следующим образом:
```
 <метка> : <индекс-регистр> , <мнемокод> , <полный адрес>
```
Обязательными элементами оператора являются за­ятые,
отделяющие мнемокод от указателя индекс-регистра и от
полного адреса, записываемого в адреснй части.
Мнемокод также всегда (за исключением единственного случая)
присутствует в записи оператора.
Остальные части оператора могут отсутствовать.

Назначение данного оператора (команда, константа,
описание и т. д.) определяется его мнемокодом. Обо­начения
мнемокодов выбраны так, чтобы по их записи
можно было легко определить назначение соответствующих операторов.

Примеры.
```
    *5 : 14 ,ХТА,
   АВТ :    ,А+Х, INT
    /7 :    ,BSS,
       :    ,XTA, А+4
            ,A*X, =R5.
 PRINT8:    ,NAME,
```

## 3. Идентификаторы

Идентификаторы служат для записи символических
обозначений.

Идентификатор — это последовательность букв и
цифр, начинающаяся с буквы.

Под «буквами» в автокоде понимаются все буквы
латинского и русского алфавитов и, кроме того, сим­олы * и /.
Максимально допустимая длина идентифи­атора
равна 8 символам (пробелы игнорируются).

Таким образом, множество допустимых идентификаторов
в автокоде шире, чем в Фортране или Алголе.

Перечислим остальные символы, составляющие
алфавит языка Madlen, но не входящие в состав
идентификаторов:
```
    + плюс              . точка
    — минус             = равенство
    ( левая скобка      : двоеточие
    ) правая скобка     ’ апостроф
    , запятая
```

В некоторых конструкциях языка (текстовых констан­тах
и комментариях) допустимы следующие энаки:
```
    ;, < >, [ ], _ (подчеркивание), !, $ или ◇.
```

Особую роль играет идентификатор, состоящий
из одного символа *. Он обозначает адрес той команды,
в которой он написан. Например, оператор ,UJ, * + 2
означает безусловный переход на левую команду ма­
шинного слова, адрес которого равен адресу данной
команды плюс 2.

Примеры идентификаторов:
```
    PROGRAM
    *15
    /101
    *АВ*
```

## 4. Мнемокоды

Мнемокод является важнейшей составной частью
автокодного оператора, определяющей назначение и
форму записи остальных его частей.

**Мнемокод — это определенная последовательность букв, понимаемых в смысле автокода, цифр и знаков + и —.//**

Особую роль играют мнемокоды команд, которые
выбраны таким образом, чтобы по мнемокоду можно было
легко определить, какой машинной операции соответст­
вует данная команда, является она короткоадресной или
длинноадресной, соответствует ее адрес некоторой
ячейке памяти или имеет особый смысл и т. д.

Мнемокоды команд, как правило, состоят из трех
символов (см. приложение 1). Исключение составляют
специальные мнемокоды (САЬЬ, ВАЗЕ и др.), а также
мнемокоды экстракодов, имеющие иногда но нескольку
равноправных обозначений (см. приложение 1А).

Второй символ мнемокода команды обычно опре­
деляет вид соответствующей машинной операции. В част­
ности, для обозначения операций сложения, вычита­
ния, умножения и деления используются символы
+, —, * и /. Дадим толкование некоторых других
указателей вида операций:

 * Т — пересылка (Transfer),
 * Z — условный переход по ω = 0 (Zerojump),
 * J — безусловный переход (Zump),
 * S — сдвиг (Shift),
 * A — логическое умножение (And),
 * O — логическое сложение (Or),
 * E — сравнение (Exclusive Or),
 * R — циклическое сложение (Round),
 * L — конец цикла (Loop).

Первый и третий символы мнемокода команды обычно
обозначают регистр машины (сумматор, регистр млад­ших
разрядов и т. д.) или тип адреса (короткий, длинный,
модифицируемый с помощью индекса-регистра и т. п.).
Если вторым символом мнемокода команды является T,
то третий его символ указывает, куда передается ин­
формация, а первый определяет источник информации.

Опишем наиболее употребительные указатели ре­истров машины и типов адресов:

 * А — сумматор (Accumulator);
 * S — магазин (Stack);
 * Y — регистр младших разрядов (Younger bits);
 * M — указатель индекс-регистра (Modifier);
 * E — «регистр» порядка, т. е. 48-42 разряды сумматора, в которых размещается порядок числа;
 * X — короткий адрес ячейки памяти;
 * V — длинный адрес, не модифицируемый по индексрегистру;
 * U — длинный адрес, модифицируемый по индексрегистру;
 * N — адрес, не являющийся адресом ячейки памяти и рассматриваемый по mod 2<sup>7</sup>,

Примеры мнемокодов:

 * ATX — запись из сумматора в ячейку памяти с коротким адресом;
 * ASN — сдвиг сумматора на число разрядов, опре­еляемое семью младшими разрядами исполнительного адреса;
 * UZA — условный переход по ω = 0 с модификацией адреса по индекс-регистру;
 * VTM — запись исполнительного адреса команды (без модификации по индекс-регистру) в индекс-регистр;
 * E+N — сложение порядка числа на сумматоре с адресом, определяемым семью младшими разрядами исполнительного адреса команды, минус 64.

Отметим, что вместо мнемонических обозначений
команд можно использовать их восьмеричные (машин­
ные) обозначения. Однако использовать такие обозначе­
ния не рекомендуется, так как это лишает команды на­
глядности и, кроме того, не позволяет пользоваться
многими возможностями автокода (например, базиро­
ванием).

## 5. Полный адрес

В адресной части команды разрешается записывать:

 1. идентификатор,
 2. целое десятичное число без знака,
 3. <восьмеричное число> В,
 4. \*
 5. адрес типа «литерал» (см. § 6),
 6. полный адрес.

Полным адресом называется любая конструкция
адресной части, состоящая не более чем из двух адресов
типов 1) - 5), взятых, быть может, со знаками + или —.
Адрес может быть пустым, ему соответствует нулевое
значение.

Примеры.
```
    A
    *+2
    X+5
    C+30B
    -AB+C15
```

Адреса, записанные в виде десятичного или восьме­
ричного числа (или их комбинации со знаками +
и —), являются абсолютными, т. е. они не зависят от
расположения подпрограммы в памяти машины. Фак­
тические значения адресов остальных типов будут
определяться при загрузке подпрограммы в память
машины. При этом вся адресная арифметика выполняется
по модулю 2<sup>15</sup>, т. е. у результирующего адреса
берется 15 младших разрядов. Отрицательные значе­
ния берутся в дополнительном коде. Например, адресу
—1 соответствует восьмеричный адрес 77777В,

## 6. Указатель индекс-регистра

Указатель индекс-регистра можно записывать в виде
десятичного числа от 1 до 15. При этом пустой или ну­
левой указатели соответствуют отсутствию модифи­
кации. Однако удобнее использовать идентификаторы,
так как это позволяет легко переопределять конкретные
значения соответствующих индекс-регистров. В по­
следнем случае идентификаторам должны быть постав­
лены в соответствие допустимые номера индекс-ре­
гистров (десятичные или ^восьмеричные^ В) с помощью
операторов эквивалентности (см. § 10).
Отметим, что пустой и нулевой указатели индексрегистра в некоторых случаях воспринимаются тран­
слятором по-разному (см. § 15),

## 7. Метки

Метка обозначается идентификатором и выполняет
несколько функций. Во-первых, она является описа­
нием данного идентификатора, т. е. однозначно его
определяет. Поэтому каждый идентификатор может быть
указан в виде метки, как правило, не более одного раза.
Во-вторых, метка, относящаяся к команде, означает,
что данная команда будет помещена в левую половину
машинного слова. В-третьих, адрес метки, указанной
перед командой, константой или оператором с мнемо­
кодом В38, является внутренним адресом данной под­
программы (см. § 15).
Метка отделяется справа двоеточием. Двоеточие
без идентификатора метки (пустая метка) означает,
что данную команду надо поместить в левую половину
слова. При этом может случиться, что предыдущее машин­
ное слово оказалось не полностью сформированным.
В этом случае транслятор автоматически дополняет его
правой командой с мнемокодом 11ТС (см. приложение 1).
Отметим, что в большинстве необходимых слу­
чаев транслятор автоматически располагает нужную
команду в левой половине машинного слова незави­симо
от наличия двоеточия.
Команды ЫВ, * 60 и * 66 всегда считаются поме­
ченными, т. е. имеющими метку, даже если она не
указана. Помеченными считаются также все команды,
непосредственно следующие за командами
УШ, ЕШ, РИШТ, ТАРЕ, БКШ, 8Д, СТХ,
* 50-т- * 57, * 61— * 65, * 67, * 70-~ * 77.
Замечание. Описанные выше случаи автома­
тической помеченности не распространяются на вось­
меричные коды операций, соответствующие указан­
ным мнемокодам.

## 8. Константы

Автокод допускает 4 типа констант:
восьмеричные (ОСТ, ЬОС),
целые (ШТ),
вещественные (КЕАЬ),
текстовые (180, С08Т, ТЕХТ, ТЕЬ).
Константы могут быть заданы как специальными
операторами (мнемокоды которых приведены выше в скоб­
ках), так и адресами типа «литерал», т. е. путем непо­
средственной записи константы в адресной части ко­
манды. В первом случае вид константы определяется ее
адресной частью. Указатель индекс-регистра при тран­
сляции констант не учитывается и может быть использо­
ван, например, для их нумерации. Указатель метки имеет
тот же смысл, что и для команд. Отметим, что для пра­
вильной трансляции констант не требуется их помечен­
ности, т. е. пустая метка перед константой не обязательна.
Константы всегда транслируются в целое число машин­
ных слов, причем для первых трех типов — в одно слово.
Константа типа ОСТ имеет в адресной части вось­
меричное число, состоящее не более чем из 16 цифр
(без буквы В справа). При трансляции константы эти
цифры будут располагаться в машинном слове слева
направо, начиная со старших его разрядов. Лишние
(сверх 16) правые цифры будут отброшены, а недоста­
ющие до полного машинного слова — дополнены ну­лями справа.

Примеры.

Восьмеричная константа, ОСТ, 4 транслируется в ма­
шинное слово 4000 0000 0000 0000, а константа ,ОСТ,
1777 7356 4216 3730 157 будет представлена в машине
как 1777 7356 4216 3730,
Константы типа ЬОС аналогичны предыдущим с той
лишь разницей, что заполнение машинного слова
производится справа налево, начиная с младших его
разрядов, и дополнение нулями производится слева,
Отметим, что константы этого типа являются анало­
гами восьмеричных констант Фортрана.
Примеры.
Восьмеричная константа ,ЬОС, 4 транслируется
в машинное слово 0000 0000 0000 0004 Однако кон­
станта ,ЬОС, 1777 7356 4216 3730 157 будет представ­
лена в виде 1777 7356 4216 3730 т, е. так же, как и в слу­
чае константы типа ОСТ.
Константы типа ШТ могут иметь в адресной части
любое целое десятичное число (без знака или со зна­
ком —), не превосходящее 240—1. В результате тран­
сляции такой константы будет образовано машинное
слово, представляющее ненормализованное число с по­
рядком 40 и с запятой, фиксированной в конце ман­
тиссы (мантиссы отрицательных чисел представляются
в дополнительном коде с 1 в 41-м разряде).

Примеры.

Целая константа ,ШТ, 38 транслируется в машин­
ное слово 6400 0000 0000 0046 При этом десятичному
числу 38 ^соответствует восьмеричное число 46, рас­
положенное в младших разрядах мантиссы. В разрядах
порядка (48—42) указано машинное представление по­
рядка 4010.
Константа ,ШТ, —5 будет представлена в виде
6437 7777 7777 7773 Здесь мантисса представлена в до­
полнительном коде с 1 в 41-м разряде.
Константы типа НЕАЬ имеют в адресной части лю­
бое десятичное число, допустимое для БЭСМ-6. При
этом правила записи аналогичны фортрапным, т, е,
обязательна десятичная точка и допустимо использо­
вание буквы Е с последующим целым числом в качестве
показателя степени при 10.

Примеры.

а) Вещественная константа ,КЕАЬ, 1*
транслируется в нормализованное машинное число
4050 0000 0000 0000 Здесь в разрядах 48-^-42 содер­
жится двоичный код 1 000 001, а в разрядах 41-^40 —
код 01. Объединяя каждые три соседних двоичных
разряда в один восьмеричный, получим в разрядах
48-^-40 восьмеричное число 405.
б) Константа ,НЕАЬ, 2. Е1 будет представлена как
4252 0000 0000 0000. Здесь в разрядах 48^-42 содер­
жится двоичный код 1 000 101, а в разрядах 41-~-37—
код 01010, что соответствует порядку 5 и положитель­
ной нормализованной мантиссе, полученной из двоич­
ного числа 10100, равного 2010. Объединяя по три
соседних двоичных разряда в один восьмеричный,
получим в разрядах 48-^37 восьмеричное число 4252.
в) Отрицательная константа ,КЕАЬ, —1, будет
транслирована в 4020 0000 0000 0000 (мантисса в до­
полнительном коде с нормализацией и с 1 в 41-м раз­
ряде).
Константы типа ШТ и КЕАЬ аналогичны целым
и вещественным константам Фортрана, т. е. их запись
и машинное представление идентичны.
Замечание. Перевод чисел ив десятичной
системы в двоичную в трансляторах с автокода л с форт­
рана (и Алгола) производится разными подпрограм­
мами. Поэтому возможны отличия в трех младших раз­
рядах мантисс машинных представлений одинаковых
вещественных констант, транслированных разными
трансляторами (если эти константы не могут быть пред­
ставлены в машине точно).
Константы типа 130 (см. приложение 2) могут со­
держать до 128 символов, которым предшествует ука­
затель пЫ, где п — число символов. Например, тексто­
вая константа
,130, 6НВЕЗМ-6
содержит 6 символов в восьмиразрядной кодировке
180. В результате трансляции этой константы будет
сформировано одно машинное слово. Отметим, что здесь
пробелы после символа Н уже не игнорируются и входят
в общее число символов константы.
При желании любой символ может быть задан своим
кодом 180, т. е. в виде восьмеричного числа (не преносходящего 377В), заключенного в апострофы (’).
Например, рассмотренная выше константа может быть
записана в виде
,180, 6НВ’105”123’М-6
Здесь вместо букв Е и 8 указаны их представления
в кодировке 180 (см. приложение 2), Заметим, что
таким способом можно задавать любые восьмиразряд­
ные комбинации 0 и 4, а не только те из них, кото­
рые соответствуют какому-либо символу 180. Ниже
будет рассмотрено использование этого способа для
записи восьмеричных констант (см. § 16). Отметим,
что символ «апостроф» может быть задан только в вось­
меричном виде, например,
,180, Ш’47’
Важно отметить, что для записи констант типа 180
можно использовать часть перфокарты по 72-ю ко­
лонку включительно. Если в указателе лН значение
п превышает число символов, информация о которых
содержится по 72-ю колонку, то вместо недостающих
символов будут добавлены пробелы,
Если п = 0 или значение п пе указано, то трансля­
тор полагает п ~ 6 и формирует машинное слово, со­
стоящее из 6 пробелов. Если п не делится нацело на 6,
то транслятор добавляет необходимое для получения
целого числа машинных слов количество пробелов.
Однако это действие не выполняется, если вслед за
оператором с мнемокодом 180 будет написан оператор
с мнемокодом СО№Г. Его адресная часть должна быть
аналогична адресной части предыдущего оператора.
Оператор с мнемокодом СХЖТ в свою очередь может
иметь продолжение.
Пример, Текстовая константа
, 180, 9НВЕ8М-6 V-, Л
Т: > СХЖТ, 2НШ
, (ХЖТ, 6Н — БИБКА
состоит из 17 символов, В результате трансляции будет
образовано три машинных слова, содержащих ука­
занный текст, дополненный справа одним пробелом
(в 8 младших разрядах третьего слова).
Метка в операторах 180 и СО№Г совпадает с адресом
слова, в которое помещен первый символ из адресной
части соответствующего оператора, В приведенном
примере метка Т соответствует второму машинному
слову (содержащему символ &).
Константы типа С08Т полностью аналогичны кон­
стантам предыдущего типа с той лишь разницей,
что кодирование символов при образовании машинных
слов будет выполнено в соответствии с кодом АЦПУ-128
(приложение 3).
Константы типа 180 аналогичны текстовым (холлеритовским) константам Фортрана. Использование кон­
стант типа 008Т связано со спецификой печатающего
устройства БЭСМ-6. Необходимость в такой кодировке
возникает при выдаче на печать текстовой информации
путем непосредственного обращения к экстракоду пе­
чати (см. [22]), что используется довольно редко.
Константы типа ТЕХТ (приложение 4) отличаются
от предыдущих кодировкой, а также тем, что в одно
машинное слово записывается 8 символов, так как каж­
дый символ кодируется 6 двоичными разрядами. Эта
кодировка используется для внутреннего представле­
ния текстовой информации в системе «Дубна». В част­
ности, в кодировке ТЕХТ представлены все наимено­
вания подпрограмм в библиотечных каталогах. Поэтому
при работе с библиотеками (см. [27], стр. 114—118)
часто используется эта кодировка.
Константы типа ТЕЬ имеют 5-разрядную кодировку
(см. приложение 5). Однако упаковка символов в ма­
шинные слова производится по 6 штук. При этом пяти­
разрядный код дополняется двумя нулями слева и одним
нулем справа, превращаясь в восьмиразрядный. Ука­
затели телетайпных регистров могут добавляться трансля гором автоматически с соответствующим увеличением
длины константы. Отметим, что константы этого типа
обычно используются только в системных программах.

## 9. Адреса типа «литерал»

Адресами типа «литерал» называются адресные
части команд, имеющих вид
=
(восьмеричное числом
=:
<(восьмеричное числор
— I (целое десятичное число])
= К ^вещественное число >
= гсН (список символов])

Знак = является признаком адреса типа «литерал».
В первом случае восьмеричное число определяет
константу типа ТОО, во втором случае — типа ОСТ.
Символы I, К и гаН указывают, что константы имеют
тип ШТ, КЕАЬ и 180 соответственно. В последнем
случае п не должно превосходить 6, так как каждая
команда может оперировать с одним машинным словом.
При появлении в полном адресе команды одной
из указанных конструкций транслятор формирует
соответствующую ей константу и заносит ее в машин­
ное слово, которое автоматически резервируется в конце
подпрограммы. Всюду, где встретится рассматривае­
мый адрес типа «литерал», он будет заменен трансля­
тором на адрес указанного машинного слова.
Примеры.
10, ХТА,=—77
, А * X, =К .5Е6
, ААХ, = : 774
, ХТ8, =ЗНАВС
, ХТА, =12
14, УТМ, =В1.
Если адреса типа «литерал» имеют одинаковые ука­
затели (скажем, К) и в результате трансляции приводят
к одинаковым машинным словам, то такие адреса
считаются эквивалентными и для определяемых ими
констант будет отведена одна и та же ячейка. Однако
такая экономия выполняется строго внутри данного
класса адресов типа «литерал» и не затрагивает иден­
тичных (в смысле машинного представления) констант,
определенных другими способами.
Примеры.
# ХТА, =К1.
, А*Х, =В. 99999 99999 999
, А/Х, = -4050
, А+Х, =6Н’202”200”0,,0”0”0’
В приведенных примерах все 4 константы будут
транслированы в одно и то же машинное слово
4050 0000 0000 0000 (вторая константа будет трансли­
рована идентично первой из-за ограничения машин­
ной точности 12 десятичными знаками). Однако экви­
валентными будут считаться лишь адреса первых
двух констант, т, е. всего будет сформировано 3 ма­
шинных слова, в каждом из которых будет одна и
та же машинная константа, написанная выше.

Использование констант типа «литерал» очень
удобно, так как это облегчает написание программ
и делает их текст более наглядным. Однако в этом слу­
чае мы не можем предвидеть порядок расположения
транслированных констант внутри подпрограммы.

## 10. Описания

Идентификаторы, используемые в указателе ин­
декс-регистра и в адресной части команд (а также
в некоторых других операторах) и не являющиеся
метками, должны быть каким-то образом определены.
Для этого служат описания.
Описать идентификатор — это значит поставить
ему в соответствие некоторое число (адрес некоторой
ячейки памяти, номер индекс-регистра, адрес типа
N и т. д.). Любой идентификатор может быть описан,
вообще говоря, не более чем одним способом. Метки,
как уже говорилось, сами являются описаниями.
Одним из часто используемых способов описания
идентификаторов является резервирование для них
ячеек памяти внутри подпрограммы. Эти ячейки ис­
пользуются для внутренних нужд подпрограммы
(например, для хранения промежуточных результа­
тов). Резервирование участка памяти осуществляется
посредством автокодного оператора вида
```
<метка)>: , В88, ^полный адресу
```

Примеры.
```
А : , В88, 1
# С : , В88,
ТАВ : , В88, 100
Т I , В88, 25В
г : , В88, Т-А
```

Здесь для идентификатора А зарезервирована одна
ячейка памяти. Метке * С соответствует конструкция
В38 с пустой адресной частью. Это значит, что адрес
метки * С совпадает с адресом следующего за ней ма­
шинного слова, в данном случае с адресом метки
ТАВ. Для идентификатора ТАВ отведен массив из
100 машинных слов. Это означает, что в подпрограмме
можно использовать адреса вида ТАВ+n (0 <= п <= 99),
каждый из которых будет соответствовать (тг+1)-му
слову из этого массива. Из примеров видно также,
что количество резервируемых слов можно задавать
в виде восьмеричного числа (с обязательной буквой В
после числа). Последний из приведенных операторов
означает, что число ячеек памяти, резервируемых для
идентификатора 2, равно разности адресов Т и А,
т, е. в данном случае десятичному числу 101.
Отметим особую роль конструкции вида
<(метка^> г 5 В88, <(пусто^>
уже встречавшейся ранее. Эта конструкция не резер­
вирует ячеек памяти, а служит всего лишь меткой
следующего за ней машинного слова. Указанное ма­
шинное слово может в свою очередь иметь метку и со­
держать любую информацию, т, е. быть командой,
константой и т. д.
Например, запись
А I , В88,
* 3 5 14, ХТА,
означает, что написанная команда имеет две эквива­
лентные метки А и * 3. Однако при необходимости
между этими двумя операторами могут быть вставлены
некоторые команды или другие операторы, и тогда
указанные метки, вообще говоря, перестанут быть
эквивалентными.
Опытные программисты, как правило, помечают нуж­
ные команды посредством «пустого» В83, т. е. не при­
вязывают метку жестко к определенной команде.
Это дает возможность вставлять или изымать перфо­
карты, «эквивалентить» различные метки и т. д., не
нарушая структуры подпрограммы.
Заметим, что описанная конструкция является автокодным аналогом фортранного оператора (ХЖТШ11Е,
В тех случаях, когда для идентификатора не тре­
буется резервировать память (например, если иденти­
фикатор использован в указателе индекс-регистра)
или когда ему можно поставить в соответствие уже
зарезервированные ячейки памяти, используется опи­
сание с помощью конструкции «эквивалентность».
Общий вид этой конструкции
```
«(идентификатор)- I , Е(}11, /полный адрес>
```

Примеры.
```
A: ,EQU, 17B
C: ,EQU, A+3
L: ,EQU, *+5
T: ,EQU, =R1
```

Эквивалентности можно располагать в любом месте
подпрограммы с соблюдением единственного условия:
к моменту своего появления в адресной части этого
оператора идентификатор должен быть уже описан
(например, через другие эквивалентности, написанные
ранее, или через метки).
Отметим, что идентификаторы, которым по смыслу
соответствуют номера индекс-регистров или адреса
типа N (см. § 4), могут быть описаны только через
эквивалентности или их модификации.
Эквивалентности чаще всего располагают в начале
подпрограммы, соблюдая порядок их следования.
Отметим, что оператор эквивалентности имеет много
общего с фортранным оператором ЕСЗШУАЬЕКСЕ.
Рассмотренных выше способов описания обычно
бывает достаточно для несложных подпрограмм. От­
метим важное свойство адресов ячеек памяти, описан­
ных рассмотренными способами. Все эти адреса являются
внутренними адресами данной подпрограммы. Это
означает, что адрес любого такого идентификатора
отличается от начального адреса подпрограммы на не­
которое (конкретное для каждого идентификатора)
число, не зависящее от расположения подрограммы
в памяти машины. Именно такие внутренние адреса
подпрограммы могут базироваться при соблюдении
дополнительных условий (см. § 15).
Мы рассмотрели способы описания внутренних
объектов подпрограммы. Прежде чем перейти к описа­
ниям внешних объектов, рассмотрим еще три типа
операторов с мнемокодами КАМЕ, ЕКБ и САЬЬ.
Мнемокод КАМЕ является составной частью заго­
ловка подпрограммы, который записывается в одной
из трех форм
```
<идентификатор> : ,NAME,
<идентификатор> : <индекс-регистр> ,NAME,
<идентификатор> : <индекс-регистр> ,NAME, ***
```

Наиболее часто используется первая из приведенных
форм записи.
Мнемокод ЕИБ служит признаком конца записи
подпрограммы (аналогично фортранному оператору
ЕШ).
Мнемокод САЬЬ служит для вызова внешних под­
программ с помощью оператора
,САЫ, (идентификатор вызываемой подпрограммы>
Возможны и другие, нестандартные способы вызова
подпрограмм (см. ниже).
Внешними объектами данной подпрограммы могут
быть массивы, являющиеся общими для несколь­
ких подпрограмм (в частности, аналоги фортранных
СОММ01М-блоков), а также массивы специального вида,
необходимые для организации обмена информацией
с магнитными барабанами и магнитными лентами (дис­
ками). Для описания таких внешних массивов в автокоде
предусмотрено несколько типов операторов, наиболее
удобным из которых является оператор с мнемокодом
ВЬОСК. Этот оператор имеет вид
( идентификатор \ . /характеристика \ , ВЬОСК, / список >
]' \и тип массивов /
блока
\ массивов
Характеристика массива определяется одной из
букв:
разместить,
Ь — массив — можно
начиная
с
произвольной ячейки памяти;
Р — страничный массив, начальный адрес которого
должен быть кратным Ю2410;
8 — секторный массив, начинающийся с адреса,
кратного 25610.
Тип массива указывается одной из следующих букв:
Р — собственный массив, т. е, массив, недоступный
другим подпрограммам;
II — несобственный массив;
С — общий массив.
В настоящее время тип II не задействован и пони­
мается как Р. Отметим, что вместо массивов с указа­
телем ЬР часто удобнее использовать конструкцию
В88, так как в этом случае массив будет внутренним
и его можно базировать (см. § 15).
Общие массивы, в отличие от собственных, доступны
любым подпрограммам, в которых они описаны теми же
идентификаторами блоков. Если идентификаторы
блоков, описывающих общие массивы, удовлетворяют
определенным требованиям (см. § 14), то эти блоки яв­
ляются автокодными аналогами фортранных СОММОКблоков.
В списке массивов указываются идентификаторы
массивов и далее в скобках длины этих массивов. При
отсутствии скобок длина массива полагается равной 1,
а при отсутствии длины внутри скобок она полагается
равной 0, и тем самым начальный адрес описываемого
массива будет совпадать с началом массива, следующего
за ним в списке.
Под массивы, описанные конструкцией В ВОСК,
резервируется участок памяти длиной, равной сумме
длин массивов, указанных в списке этого блока. При
этом адрес начала первого массива совпадает с адресом
идентификатора блока.
Примеры.
А ; ЬС, ВЬОСК, В(3), Б(5), СБ, ЕР( ), * 50(12)
Здесь описан общий массив (начинающийся с произ­
вольного адреса) длиной 21 машинное слово. При этом
длина массива СБ равна 1, а начальные адреса масси­
вов ЕГ и * 50 совпадают,
* АВС * ; ЬС, ВЬОСК, А, В(7), С(18)
Этот блок является автокодным налогом фортранного СОММО!Ч-блока, описанного оператором
СОММОЭТ /АВС/ А, В(7), С(18)
В листе загрузки (см. [27], стр. 50) идентификаторы
фортранных СОММСШ-блоков записываются «по-автокодному», т, е. обрамляются звездочками.
Конструкция ВЬОСК может располагаться по 72-ю
колонку перфокарты включительно. Список в ее ад­
ресной части может быть продолжен применением
конструкции СО№Г,

Пример.
```
А : ЬС, ВЬОСК, В (3)
, ОЖТ, Б (5), СБ
, СОШ\ ЕГ ( ), * 8(} (12)
```
Это другая запись рассмотренного ранее примера.

Вместо описания группы массивов с помощью кон­
струкции ВЬОСК можно использовать оператор опи­
сания отдельного массива с последующими эквивалент­
ностями. Рассмотренный выше пример можно записать
следующим образом:
А : , ЬС, 21
В : , ЕС}!!, А
Б : , Е(}Б, В+3
СБ : , Е(}11, Б+5
ЕР : , Е(*Б, СБ-И
* 3(} : , Е(ЗБ, ЕР
Здесь первый оператор описывает массив А длиной,
равной общей длине блока (резервируя тем самым
участок памяти длиной 21 слово), а все остальные
массивы, составляющие блок, описываются в виде
цепочки эквивалентностей. Этот пример иллюстри­
рует удобство конструкции ВЬОСК.
К числу внешних объектов подпрограммы отно­
сятся все подпрограммы, которые ею вызываются.
Как сказано выше, вызов подпрограммы можно осу­
ществить с помощью оператора с мнемокодом САЬЬ.
Этот стандартный способ вызова не требует (но и не
исключает) специального описания вызываемой под­
программы. Отметим, что в этом случае возврат в вызы­
вающую подпрограмму производится на левую команду
следующей ячейки, адрес которой автоматически за­
поминается в 13-м индекс-регистре.
Вызов подпрограммы можно осуществить также
оператором
13, У1М, ^идентификатор подпрограммы)*
или, например, так:
13, УТМ, * 10
9 III, ^идентификатор подпрограммы^
* 10 : ^ В88,
т. е. с возвратом на заранее предписанную ячейку
(в данном случае на метку * 10). Во всех подобных
случаях необходимо описание вызываемой подпро­
граммы, что делается оператором
```
<идентификатор подпрограммы> : ,SUBP,
```

Рассмотренный оператор является аналогом фортранного оператора EXTERNAL и, следовательно,
он необходим в тех случаях, когда вызов подпрограммы
производится через посредство другой подпрограммы
(т. е. путем указания наименования вызываемой под­
программы в качестве фактического параметра при вызове
подпрограммы-посредника).
Рассмотрим теперь оператор вида
^идентификатор} : ,БРАТКУ,
который служит для описания дополнительного входа
в подпрограмму аналогично фортранному оператору
Е1ЧТВУ.
Дополнительные входы позволяют объединить не­
сколько подпрограмм в одну, с тем чтобы использовать
одни и те же константы и не описывать лишних общих
блоков. Однако каждый вход является самостоятельной
подпрограммой в том смысле, что обращение к любому
входу полностью аналогично вызову подпрограммы.
Общее число входов в подпрограмму (включая основ­
ной, описанный заголовком) не должно превосходить 20.
Входы, к которым есть обращения, описываются ана­
логично описаниям вызываемых подпрограмм.
Отметим, что, в отличие от Фортрана, тип любого автокодного Е№ГВУ (81ШВ01ГГШЕ, Е1ШСТКЖ и т. п.),
равно как и список его формальных параметров, не
обязан совпадать с таковыми у основного входа (см. § 14).
Заметим, что использование любого входа в под­
программу внутри самой подпрограммы возможно
либо с помощью оператора с мнемокодом САЬЬ, либо
при наличии дополнительного описания используе­
мого входа как метки (например, через В88).
Заметим также, что команда, следующая за опера­
тором с мнемокодом БИТВУ, считается помеченной.
Укажем еще несколько описательных конструк­
ций, используемых сравнительно редко.
При составлении системных подпрограмм (например,
работающих в диспетчерском режиме) могут быть
известны абсолютные адреса некоторых команд и кон­
стант. Для описания таких адресов используются спе­
циальные разновидности конструкции ВБОСК, поз­
воляющие задавать начальные адреса блоков как
в десятичной, так и в восьмеричной системе.

Примеры.
```
* 20 : В, ВЬОСК, А (23), Б (2)
* 25 : , ВЬОСК, А (15), В (6)
```
Первая конструкция эквивалентна описаниям
```
А : , Е(}11, 20В
Б : , ЕрЬ, А+23
```
Вторая конструкция равнозначна описаниям
```
А : , Е(}Б, 25
В : , Е0Ы, А+15
```
Еще одна разновидность конструкции ВЬОСК
позволяет описывать последовательности эквивалент­
ностей, что видно из примера
```
М : I, ВЬОСК, А, В (15), С (6)
```
Эта конструкция эквивалентна описаниям
```
А : , Е0Ы, М
В : , Е(}Б, А+1
С : , ЕС^Б, В+15
```
Идентификатор М, естественно, должен быть уже
описан каким-то способом (например, через В88).
Это одно из немногих исключений из правила, согласно
которому допускается не более чем однократное опи­
сание идентификатора в виде метки (см. § 7).
Отметим, что рассмотренные три разновидности
конструкции ВЬОСК не резервируют ячеек памяти.
Рассмотрим еще несколько разновидностей экви­
валентности. Конструкция вида
```
^идентификатор^) : ,\УЕ(}, ^полный адресу
```
называется косвенной эквивалентностью. Она приписы­
вает идентификатору значение, равное содержимому
1-|-15 разрядов слова с заданным полным адресом
в момент загрузки подпрограммы.
Косвенная эквивалентность позволяет, в частности,
резервировать (например, посредством оператора
В83) участки памяти переменной длины. В этом слу­
чае длина участка может быть задана, например,
с помощью оператора БАТА, написанного в РНООКАМ.
Ячейка памяти, куда засылается нужное значение
длины (в виде целой константы) должна быть, есте­ственно,
элементом COMMON-блока, описанного в автокодной подпрограмме.

Конструкция
```
<идентификатор> : ,P*P, (<полный адрес>) (<полный адрес>)
```
приписывает идентификатору значение, равное произ­
ведению полных адресов (по модулю 216), приведенных
в адресной части.

Эта конструкция позволяет удобным образом ре­
зервировать участки памяти под многомерные мас­
сивы, в том числе под массивы с переменными раз­
мерностями (в сочетании с косвенной эквивалент­
ностью).

Аналогично, конструкция
```
<идентификатор> : ,P/P, (<полный адрес>) (<полный адрес>)
```

приписывает идентификатору значение, равное ча­стному
(округленному до целого) от деления полных
адресов, указанных в адресной части. Одно из воз­
можных применений этой конструкции — определение
номера страницы или абзаца памяти по заданному
значению адреса. Необходимость в этом возникает,
например, при обращении к экстракоду обмена *70.

Замечание. В некоторых подпрограммах,
составленных до 1970 г,, в качестве заголовка исполь­
зовалась конструкция
```
 : ,SUBP, <идентификатор>
```
являющаяся «наследием» автокода SIBESM-6 [38].
Использовать ее в качестве заголовка не рекомен­дуется.

## 11. Параметрические команды

Иногда бывает удобно задавать константы в формате
команд. Использование для этих целей команд не
всегда возможно, так как не всякая константа может
быть представлена в виде команды. Для записи кон­
стант в виде команд служат так называемые параметрические команды.
Мнемокод параметрической команды имеет вид
```
Z <восьмеричпое число от 0 до 37B>
```
Параметрические команды транслируются как
команды с длинным адресом.

Пример.
```
5 ,Z31, 06412B
```
транслируется в машинную команду
```
05 31 06412
```

## 12. Данные и рассылки

В ряде случаев возникает необходимость занести
некоторую исходную информацию в определенные
ячейки памяти, не являющиеся внутренними адресами
подпрограммы. Для этого служат специальные опера­
торы автокода, располагаемые в конце подпрограммы.
Эти операторы описывают величины, подлежащие рас­
сылке (данные), и адреса ячеек памяти, куда эти ве­
личины рассылаются (указания о рассылке), В под­
программе данные предшествуют указаниям о рас­
сылке.
Группа данных начинается с оператора
,БАТА,
и может состоять из констант любого типа.
Указания о рассылке представляются последова­
тельностью пар операторов вида
гс1т ЗЕТ, Ах
и2,
> А2
полные
где гсх и гс2 — целые десятичные числа, Ах и А 2
адреса. Такая пара операторов осуществляет пересылку
группы из пх слов, начинающейся с адреса Ах, в мас­
сив ячеек, начинающийся с адреса А2, гс2 раз.
Пересылать можно любые объекты подпрограммы
(команды, константы), так что при наличии указаний
о рассылке группа данных может и отсутствовать.
Отметим, что данные не загружаются в память
машины. Загрузчик производит их рассылку согласно
указаниям в подпрограмме, после чего уничтожает
«оригиналы». Таким образом, данные можно исполь­
зовать лишь по их новым адресам. Чаще всего это
адреса из общих блоков.

Пример. Запись вида
```
    ,DATA,
 A: ,REAL, 1.
    ,ISO , 14НАВТОКОД MADLEN
  4 ,SET , A
  1 ,    , TABLE
```
означает однократную рассылку написанных выше
констант (занимающих 4 машинных слова, начиная
с адреса А) в ячейки памяти, начиная с адреса ТАВЕЕ.
При этом указанные константы расположатся в ма­
шинных словах ТАВЬЕ и от ТАВЬЕ-|-1 до ТАВЬЕ-{-3
соответственно. По этим «новым» адресам (но не по
«старым»!) их можно использовать в подпрограмме.

Рассмотренные конструкции выполняют те же
функции, что и фортранный оператор БАТА,

## 13. Комментарии

Комментарии в автокоде можно записывать по
фортранным правилам (буква С в первой колонке перфо­
карты-комментария). Кроме того, на каждой перфо­
карте для комментария отведены колонки с 73-й
по 80-ю. В большинстве случаев (за исключением
операторов с мнемокодами 180, ВЬОСК, С01ЧТ и не­
которых других «длинных» операторов) поле коммента­
рия начинается с 43-й колонки. Для того чтобы запись
оператора можно было продолжить за 42-ю колонку,
в первой колонке надо пробить управляющий символ Ь.
Однако необходимости в этом обычно не возникает.
Наоборот, часто возникает необходимость размещения
комментария ранее 43-й (или 73-й) колонки. Для этого
служит точка, которая отделяет комментарий от ад­
ресной части команды.
Примеры.
```
, AAX , =:774. ВЫДЕЛЕНИЕ ПОРЯДКА.
, E+N , 64. НОРМАЛИЗАЦИЯ.
```

## 14. Правила оформления автокодных подпрограмм

При оформлении автокодных подпрограмм допу­
скается нестандартность. Однако соблюдение опреде­
ленных правил при оформлении автокодной подпро­
граммы позволяет ей, с одной стороны, не «мешать»
работе других подпрограмм и, с другой стороны, вы­
зывать ее некоторым стандартным образом (в том числе
из фортранных и алгольных подпрограмм). Такая
автокодная подпрограмма может быть включена в биб­
лиотеку программ общего пользования.
Первая группа правил касается использования
индекс-регистров и режимов работы арифметического
устройства.
Эти правила предусматривают, что индекс-регистры
1-7-7 можно использовать лишь при условии после­
дующего восстановления их прежнего состояния.
Индекс-регистры 8-—12 и 14 можно использовать без
последующего восстановления. Это означает, что при
выходе из любой подпрограммы состояние этих
индекс-регистров не определено, т. е. указанные индексрегистры могут быть «испорчены».
Индекс-регистр 13 играет особую роль — в нем хра­
нится адрес возврата. Это означает, что если некото­
рая подпрограмма в свою очередь вызывает другую
подпрограмму (скажем, посредством оператора САЬЪ),
то свой адрес возврата она должна, вообще говоря,
сохранить (например, путем записи содержимого ин­
декс-регистра 13 в некоторую ячейку памяти).
Индекс-регистр 14 является «рабочим» регистром.
Его состояние «портится» любым экстракодом (остальные
индекс-регистры экстракодами не «портятся»).
Индекс-регистр 15 является счетчиком магазина
и устанавливается мониторной системой. Стандарт­
ное его значение равно 53401В, 55401В или 73401В
(в зависимости от объема памяти, выделенной для за­
дачи). Объем магазина во всех случаях равен 377В,
Переполнение или исчерпание магазина диагностиру­
ется при счете.
Соглашение о регистре режима и блокировок пре­
дусматривает, что значение этого регистра при входе
в автокодную подпрограмму равно 6 и должно быть
таким же на выходе. Напомним, что это стандартное
значение соответствует режиму выполнения арифме­
тических операций с нормализацией и с блокировкой
округления и, кроме того, значению признака группы
«логическая». Установка этого стандартного значения
проще всего делается командой ,1МТК, 6.
Вторая группа правил касается способа пере­
дачи фактических параметров при совместном исполь­
зовании фортранных (алгольных) и автокодных под­
программ.
При вызове фортранной подпрограммы, имеющей
параметры, из автокодной необходимо загрузить
адреса фактических параметров вызываемой подпро­
граммы в магазин в порядке их следования. Пусть,
например, мы хотим оформить вызов подпрограммы
аналогично фортранному оператору
САЬЬ 811В (А, В, С)
Тогда надо написать такую последовательность опера­
торов (не обязательно с использованием индекс-ре­
гистра 14):
14, УТМ, А
, 1Т8, 14
14, УТМ, В
, 1Т5, 14
14, УТМ, С
, 1Т5, 14
, САЬЬ, ЗИВ
Как видим, магазин «проталкивается» вниз столько
раз, сколько фактических параметров. При этом сна­
чала в магазин записывается содержимое сумматора,
которое должно быть восстановлено перед выходом
из подпрограммы 8ПВ.
Если подпрограмма 811В аналогична фортранной
Р1ЖСТКЖ, а не 811ВКСШТШЕ, то вызов ее будет
отличаться тем, что после возврата из такой подпро­
граммы необходимо выполнить одну из команд мага­
зинного считывания. Чаще всего выполняют команду
с мнемокодом 8ТХ. При этом происходит запись зна­
чения функции, полученного на сумматоре, в ячейку па­
мяти и одновременно восстановление состояния сум­
матора, которое было до вызова подпрограммы.
Иногда при вызове Р1ШСТКШ адрес первого пара­
метра засылают не в магазинном режиме (,ITA, 14
вместо ,ITS, 14). В этом случае после возврата из
подпрограммы дополнительного магазинпого считы­
вания не делают, оставляя на сумматоре значение
функции.
Извлечение адресов фактических параметров из
магазина производится в порядке, обратном порядку
их записи в магазин. Напомним, что адрес последнего из
них находится на сумматоре. Пусть мы составляем
на автокоде подпрограмму, аналогичную фортранной
811ВВСШТШЕ 8ИВ (А, В, С). Тогда извлечение ад­
ресов фактических параметров можно сделать, напри­
мер, командами
, 8Т1, 14.С
, 8Т1, 12.В
, АТГ, И.А
Как видим, в магазине осталось прежнее значение сум­
матора. Перед выходом из подпрограммы надо уста­
новить правильное состояние счетчика магазина, напри­
мер, командой ,8ТХ, либо 15 ,ХТА, . Отметим, что
после выполнения любой из этих команд будет уста­
новлен нужный признак группы «логическая». В слу­
чае Е1ШСТКЖ такого дополнительного магазинпого
считывания делать нельзя. Иначе говоря, Г1ЖСТ1(Ж
с п параметрами должна произвести «выталкивание»
магазина п—1 раз, а ЗИВКОИТШЕ — п раз.
Заметим, что в случае большого числа параметров
для извлечения их адресов из магазина указанным спо­
собом может не хватить индекс-регистров. В этом слу­
чае надо либо записывать адреса параметров в некото­
рые ячейки памяти (как делается, например, в фортранных подпрограммах), либо извлекать их по частям, что
требует известной аккуратности. Поскольку в автокодных подпрограммах число формальных параметров
обычно невелико, то индекс-регистров чаще всего
хватает.
В случае когда на автокоде пишется аналог Фортран­
ной 8ПВВ011ТШЕ без параметров, эта подпрограмма
должна сохранить состояние сумматора (т. е. выпол­
нить на входе 15, АТХ, либо ,ХТ8, или ,1Т8,), При
выходе надо проделать обратную операцию восстанов­ления состояния сумматора,

Аналогом фортранной РНООНАМ на автокоде яв­
ляется подпрограмма, имеющая заголовок
```
 PROGRAM: ,NAME,
```
либо один из входов
```
 PROGRAM: ,ENTRY,
```
Третья группа правил касается выбора наиме­
нований подпрограмм (входов), совместимых с фортра­
ном (Алголом), и общих блоков, совместимых с фортранными СОММОГЧ-блоками.
Для того чтобы автокодную подпрограмму (либо
отдельный ее вход) можно было вызывать из Фортран­
ной (алгольной) подпрограммы, наименование этой
подпрограммы (или входа) должно быть идентифика­
тором, допустимым для Фортрана или Алгола. Это
означает, что рассматриваемый идентификатор должен
состоять не более чем из 6 символов и не содержать
символов * и /.
Аналогичное правило для идентификаторов общих
блоков, совместимых с фортранными СОММ(Ж-блоками, выглядит так: идентификатор общего блока
должен начинаться и оканчиваться звездочкой, а между
звездочками должен содержать не более б символов,
допустимых для фортранного идентификатора. Напри­
мер, общий блок вида
* ВЬОСК 1 * : ЬС, ВЬОСК, А (10), В (25)
имеет тот же смысл, что и фортранный оператор
С0ММ01Ч/ВЬ0СК1/ А (10), В (25)
Описание же вида
ВЬОСК! : ЬС, ВЬОСК, X (5), У (10)
не имеет фортранного аналога и, стало быть, этот блок
недоступен никакой фортранной подпрограмме,
В тех случаях, когда автокодная подпрограмма не
предназначается для использования в фортранных или
алгольных подпрограммах, ее наименование лучше
выбрать недоступным для них, равно как и наименова­
ния ее общих блоков.

Приведем теперь схему построения подпрограммы
на автокоде
```
    Заголовок
    Команды
    Константы и BSS
    Данные
    Указания о рассылке
    .END,
```
Комментарии можно располагать ранее заголовка
и в любом месте до ,ЕХБ, . Описания могут распола­
гаться в любом месте после заголовка с единственным
условием: описание любого идентификатора (кроме
меток) должно предшествовать его использованию.
Операторы с мнемокодом В38 и непустой адресной
частью (т. е. фактически резервирующие место в памяти)
могут перемежаться константами. Их рекомендуется
располагать после констант, которые в свою очередь
обычно располагаются после команд. Пустые конструк­
ции В88 могут располагаться произвольно среди ко­
манд и констант. Данные и указания о рассылке рас­
полагаются в конце подпрограммы.
Подпрограмма должна составляться в расчете на то,
что она будет помещена загрузчиком в произвольную
область памяти. Это означает, что адреса команд с ко­
ротким адресом (кроме некоторых) должны быть, вообще
говоря, каким-то образом модифицированы. Этому
важному вопросу посвящен следующий параграф.

## 15. Базирование

Как сказано выше, многие команды с коротким адре­
сом требуют модификации своей адресной части. Самым
простым способом такой модификации является запись
вида
```
    ,UTC, A
    ,XTA,
```
вместо записи
```
    ,XTA, A
```
Возможна и такая запись:
```
    J ,VTM, A
    J ,XTA,
```
Однако эти способы неэкономны, так как для модифи­
кации каждой команды обычно требуется дополни­
тельная команда. В случае большого числа команд
с коротким адресом более эффективным приемом мо­
дификации адресов является базирование.

Суть базирования состоит в следующем. Большинст­
во команд с коротким адресом оперирует либо с абсолют­
ными адресами, допустимыми для таких команд (ASN,
E+N, YTA, и т. п.), либо с внутренними адресами
данной подпрограммы. Каждый внутренний адрес под­
программы можно представить в виде *C+D, где
*C - адрес начала подпрограммы и D не превосходит
длины подпрограммы, которая обычно не превышает
07777В. Указанные команды с коротким адресом
(являющимся внутренним адресом подпрограммы) вида
```
    ,<мнемокод>, A
```
переписывают так:
```
    J ,<мнемокод>, А-*С
```
При этом в индекс-регистр J должен быть занесен
адрес базы, т. е. в начале участка программы должна
быть выполнена команда
```
    J ,VTM, *C
```
В результате такого видоизменения команд с коротким
адресом их исполнительные адреса остаются преж­
ними, но в адресной части всюду получаются значе­
ния, допустимые для команд с коротким адресом,
В автокоде тас11еп предусмотрена возможность авто­
матического базирования, при котором не требуется
переписывать команды, подлежащие базированию. Ав­
томатическое базирование может производиться не­
сколькими способами.
Наиболее употребительным является базирование по
одному индекс-регистру или локальное базирование.
На протяжении этой главы термином «базирование»
обозначается именно такой способ базирования. Этим
способом могут базироваться лишь внутренние адреса
подпрограммы. Базирование выполняется на линейных
участках подпрограммы, каждый из которых открыва­
ется заказом на базирование (см* ниже) и закрывается
либо очередным заказом на базирование, либо отменой
базирования (или оператором ,ЕХБ,),
Базируются только команды, удовлетворяющие усло­
виям:
1) команда должна быть с коротким адресом,
2) команда должна быть с пустым указателем индексрегистра,
3) полный адрес команды должен быть внутренним
адресом подпрограммы.
Команды с непустым (в том числе и нулевым) указа­
телем индекс-регистра, полные адреса которых являются
внутренними адресами подпрограммы, транслируются
в пару команд. Например, команда вида
М, ХТА, А
транслируется так же, как пара команд
, БТС, А
М, ХТА,
Заказ на базирование (без установки базового ин­
декс-регистра) имеет вид
I, ВАЗ, * С
Здесь * С есть адрес базы, I — базовый индекс-регистр.
Более часто используют оператор вида
I, ВАЗЕ, * С
который, кроме заказа на базирование, производит
и установку базы. Этот оператор эквивалентен паре
операторов
I, ВАЗ, * С
I, УТМ, * С
Отмена базирования производится либо новым за­
казом на базирование, либо оператором
I, ВАЗ, <(пусто)>
Отметим, что в качестве адреса базы можно исполь­
зовать любой внутренний адрес А такой, что для каж­
дого внутреннего адреса К выполняется условие: А —
—10000В ^ К ^А-|-7777В. В качестве базового регистра
часто используется один из индекс-регистров 8-^-12.
В случае, когда подпрограмма содержит вызовы
других подпрограмм, удобнее использовать в ка­
честве базового регистра один из регистров 1-г-7,
Заметим, что точные сведения о том, какие адреса
пробазированы, а какие нет, всегда можно получить
из текста подпрограммы на языке загрузки, располо­
женного на листинге слева от автокодного текста (см.
§ 17). В случае базирования транслированная команда
будет содержать базовый индекс-регистр.
Другим способом базирования является глобаль­
ное базирование всей памяти с помощью трех индексрегистров. Суть этого способа (используемого в основ­
ном в больших программах) состоит в следующем.
Адреса от —10000В до 07777В не требуют базирования.
Остальные адреса могут быть базированы с помощью
трех индекс-регистров, равных соответственно 20000В,
40000В и 60000В, так как любой из этих адресов отстоит
от одного из трех указанных значений индекс-регистров
не далее чем на 10000В влево и не далее чем на 07777В
вправо. Заказ на глобальное базирование задается за­
головком подпрограммы вида
«(идентификатор^: И, NАМЕ,
где К — целое десятичное число от 1 до 13. Базирование
производится загрузчиком, который подбирает над­
лежащий индекс-регистр из набора К, К—1, К+2 для
каждой из команд, подлежащих базированию. Зна­
чения индекс-регистров с номерами В, В+1, К+2,
равные 20000В, 40000В и 60000В соответственно,
устанавливаются самой подпрограммой.
При глобальном базировании базируются все ко­
манды с коротким адресом, пустым указателем индексрегистра и адресной частью, превышающей 07777В.
Тем самым исключается базирование команд с мнемо­
кодами АЗГ^, 1МТВ и т. п., адреса которых базировать
не надо. Команды с коротким адресом и непустым ука­
зателем индекс-регистра заменяются двумя командами,
как описано ранее. Если такие команды базировать
не надо, то заголовок подпрограммы должен быть
видоизменен так!
(идентификатор)? 8 В ^АМЕ, ***
Параметрические команды во всех случаях не бази­
руются,

Следующие два способа базирования предназна­
чены в основном для использования при составления
системных подпрограмм.
Иногда возникает необходимость оформления под­
программы в виде, позволяющем использовать ее на
любом участке памяти без предварительной «настройки-?
адресов. Такую «перемещаемую» подпрограмму можно
получить, например, путем базирования ее адресов
по некоторому базовому адресу.
Заказ на такое базирование производится операто­
ром вида
М, КЕЬ, В
Здесь в качестве М обычно указывается индекс-ре­
гистр 14 (устанавливаемый загрузчиком), а в качестве
В — начальный адрес базируемого участка подпрограм­
мы (например, начальный адрес подпрограммы).
При необходимости базирования адресов, завися­
щих от внешних объектов, заказ на базирование задается
оператором вида
М, ВЕЬЗ, В
Отмена любого из двух видов базирования произво­
дится оператором
М, КЕЬ, <пусто>

## 16. Примеры автокодных подпрограмм

Приведем примеры несложных автокодных подпрограмм,
из которых читателю станет яснее, как на практике использу­
ются различные конструкции языка Madlen.

Рассмотрим подпрограмму вычисления скалярного произ­
ведения двух N-мерных векторов. Оформим ату подпрограмму
как FUNCTION SCAL (A, B, N)
```
8САЬ:,КАМЕ,.Г1ЖСТКЖ8САЬ (А, В, И)
, 8Т1, 14.N
, 8Т1, 12.В
, АН, 11.А
, 1ЧТВ, 3
14 , ХТА,
, 1)ТС,=11.(*)
, X—А, . 1—N
АТ1, 14
, ОТК, 18
, ХТА,
*!:,
11,
12,
И,
12,
15,
14,
,
13,
,

В88,
ХТ8,
А * X,
ОТМ, 1
1ГГМ, 1
А+Х,
УЬМ, * 1
ТУГВ, 6
Ш,
ЕШ,
225
```
Как видно из текста подпрограммы, базирование здесь не
понадобилось, так как используется всего одна команда (*),
удовлетворяющая всем условиям базирования.

Рассмотрим теперь подпрограмму перекодировки целого числа,
не превосходящего 2<sup>18</sup>-1, в код ISO. Здесь перекодировка
означает, что каждая восьмеричная цифра этого числа переко­
дируется в соответствующую цифру, заданную в коде ISO
(см. Приложение 2). Например, целое десятичное число 21,
представленное в машине как 6400 0000 0000 0025, будет
пере­кодировано в машинное представление, соответствующее к
константе ,1ISO, 6Н000025.

На первый взгляд решение этой задачи представляется
сложным. Однако с помощью команды разборки (с мнемокодом
AUX) получается очень простое и изящное решение. Сначала
надо сдвинуть содержимое сумматора влево так, чтобы 18 млад­
ших его разрядов переместились в старшие разряды. Затем про­
изводится разборка 18 старших разрядов на все машинное слово
так, чтобы каждая восьмеричная цифра оказалась в трех млад­
ших разрядах соответствующего байта. При этом пять старших
разрядов каждого байта будут нулями. Теперь для получения
нужного результата достаточно логически сложить содержимое
сумматора с константой, имеющей 60В в каждом байте. Запишем
решение в виде следующей автокодной подпрограммы.
```
ШТ180:,
8,
,
14 ,
,
,
,
13,
,

^МЕ,.РШСТКЖ ШТ130 (ШТ)
ВА8Е, •
АТ1, 14. ШТ
ХТА,
АЗГ^, 64—30
АПХ,=6Н'7"7"7"7"7"7'
АОХ,=6Н,60"60"60"60"60"60'
Ш,
ЕШ,
```
Мы использовали кодировку ISO для задания восьмеричных
констант. Здесь это удобнее, чем использование констант типа OCT
или LOG.

## 17. Стандартный массив

Стандартный массив (или модуль загрузки) явля­
ется результатом работы транслятора с автокода.
Он включает в себя транслированную подпрограмму
на языке загрузки и таблицу описаний, содержащую
информацию, необходимую загрузчику для размеще­
ния подпрограммы в оперативной памяти. Текст стан­
дартного массива печатается слева от автокодного текста
при условии задания соответствующего режима печати
(см. § 19).

Каждая команда печатается в две строки по фор­
мату машинных команд. Верхняя строка, которая соот­
ветствует левой команде, снабжается восьмеричным
относительным адресом данной команды в подпрограм­
ме, печатаемым слева от команды.
Индекс-регистр указывается в восьмеричном виде,
а адресная часть состоит из 4 восьмеричных цифр у
команд с коротким адресом и из 5 восьмеричных цифр
у команд с длинным адресом.
Неполные машинные слова дополняются правыми
командами
0022 00000
В случае, если команда базируется, в ней указыва­
ется базовый индекс-регистр, а адресная часть равна
разности между полным адресом данной команды
и адресом базы. Если этот относительный адрес ока­
зался отрицательным, то в адресной части указывается
адрес 4000В+н, где п есть номер строки в таблице
описаний (это справедливо для всех отрицательных
коротких адресов). Если используется адрес типа «ли­
терал», то он базируется при наличии заказа на базиро­
вание. В случае, когда базируемая команда имеет
непустой указатель индекс-регистра, она транслиру­
ется в две команды (см. § 15).
Если базирование не заказано, то любой крроткий
адрес, не являющийся абсолютным, будет иметь вид
4000В-(-/г, т. е. будет оформлен в виде ссылки на таб­
лицу описаний. Заметим, что абсолютные адреса без
модификации допустимы лишь в случаях, когда им
соответствуют не ячейки памяти, а некоторые другие
объекты (например, в командах с мнемокодами А81Ч,
№ГВ, АТ1 и т. п.). Исключение составляют физичес­
кие адреса и адреса специальных ячеек мониторной
системы, используемые, как правило, в системных
подпрограммах.
Длинный адрес вида 40000В+га означает ссылку
на п-й адрес относительно начала подпрограммы, а
длинный адрес вида 74000ВД-И — ссылку на гс-ю строку
таблицы описаний. Отметим, что начальная (нулевая)
строка таблицы описаний содержит идентификатор
данной подпрограммы в коде ТЕХТ.

## 18. Диагностика ошибок

Транслятор с автокода обнаруживает всевозможные
формальные ошибки в подпрограмме, не связанные со
способом загрузки ее в память машины. Это означает,
что «незаконное» использование коротких адресов не
может быть обнаружено транслятором.
В зависимости от вида ошибки игнорируется либо
весь ошибочный оператор, либо его часть. К каждому
ошибочному оператору может быть выдано несколько
диагностических текстов, причем они, как правило,
печатаются непосредственно перед ошибочным опера­
тором.
Некоторые ошибки прекращают дальнейшую тран­
сляцию. К числу таких ошибок относятся (в скобках
указана диагностика):
1) отсутствие заголовка подпрограммы (ОТСУТ­
СТВУЕТ ЗАГОЛОВОК ПОДПРОГРАММЫ),
2) слишком большое число используемых иденти­
фикаторов либо наличие более 20 входов (ПЕРЕПОЛ­
НЕНА ТАБЛИЦА ОПИСАНИЙ),
3) для размещения подпрограммы требуется более
23 листов оперативной памяти (ДЛИНА ПОДПРОГРАМ­
МЫ ПРЕВЫШАЕТ ВОЗМОЖНОСТИ МАШИНЫ),
4) при обнаружении свыше 100 ошибочных опера­
торов (ОЧЕНЬ МНОГО ОШИБОК),
5) при некоторых ошибках в адресе оператора
Б83 (НЕЯВНООПРЕДЕЛЕННЫЙ ИДЕНТИФИКА­
ТОР В85).
Остальные ошибки не препятствуют дальнейшей
трансляции. Среди них наиболее часто встречаются
ошибки, связанные с использованием неописанных
идентификаторов либо идентификаторов, описанных
более одного раза (дважды описанных). Отметим, что
обнаружение таких идентификаторов входит в функции
транслятора с автокода на этапе трансляции фортрапных подпрограмм с языка та<11еп на язык загрузки
(остальные ошибки обнаруживаются транслятором
с Фортрана).

## 19. Управляющие карты, редактирование, сервис

Тексту автокодной подпрограммы в пакете задачи
должна обязательно предшествовать управляющая карта
* АЗЗЕМВИЕК
которая служит признаком того, что далее следует
автокодный текст. При отсутствии других управляю­
щих карт (если печать не отменена картой * N0—1Л8Т)
пользователь получает отредактированный текст авто­
кодной подпрограммы, напечатанный в два столбца
(билистинг), без текста стандартного массива.
Для получения текста стандартного массива необ­
ходимы две подряд стоящие управляющие карты
* САЬЬ _ РШТЬАС *
п1
Здесь п может принимать значение 0, 4 или 6. Если
п = 0, то печать производится в два столбца. При
п — 4 (или 6) печать производится в один столбец.
При печати в виде билистинга «длинные» операторы
будут распечатаны в две строки.
При наличии управляющей карты * РЕЛЬ_,Ы8Т
после текста подпрограммы будет выдана таблица
описаний, таблица ссылок и список неиспользованных
идентификаторов.
Автокодный текст, выдаваемый на печать, редакти­
руется, т. е. разделители (двоеточия, занятые и точки)
печатаются в определенных позициях, метки и адрес­
ные части выравниваются по левым символам, а ука­
затели индекс-регистров — по правым. Ошибочные опе­
раторы печатаются без редактирования.
Имеется возможность частичной распечатки текста
подпрограммы, что делается с помощью управляющих
карт * РЕЛЬ^ЫЗТ и * ГТО—.Ы8Т, расположенных
внутри подпрограммы. При этом режим печати, опре­
деленный в пакете перед подпрограммой, запомина­
ется и восстанавливается после ее трансляции.
Внутри текста подпрограммы (до первой команды)
может быть поставлена управляющая карта
```
*MOSU␣A
```

где А — пятизначный восьмеричный адрес, В этом
случае текст подпрограммы будет печататься не с относи­
тельной адресацией (т, е, не с адреса 00000), а начиная
с адреса А.

## 20. Советы и рекомендации

При автономной отладке Двтокодных подпрограмм,
когда пакет задачи будет малым по объему, отлаживае­
мые подпрограммы часто будут загружаться по адресам
памяти, не превосходящим 07777В, и тем самым при
загрузке не будут выявлены случаи использования
коротких адресов бея модификации. При загрузке
по адресам, превосходящим 07777В, такая «отлаженная»
подпрограмма может не пойти. Для исключения подоб­
ных случаев необходимо в отладочной РНООКАМ
описать фиктивный массив длиной не менее 3600. Во
всяком случае, необходимо проследить, чтобы отла­
живаемая подпрограмма была загружена в память,
начиная с адреса не менее 10000В.
Если, наоборот, необходимо загрузить подпрограмму
на адреса до 07777В, то в РНООКАМ не должно быть
больших массивов и соответствующая подпрограмма
должна быть описана в РНООКАМ оператором ЕХТЕККАЬ (или его автокодным аналогом). Тогда она будет
загружена вслед за РНООКАМ. Отметим, что подпро­
граммы, описанные в операторе ЕХТЕКХАЬ, за­
гружаются в обратном порядке, т. е. первой загрузится
та, что описана последней.
При составлении подпрограмм с многими входами
необходимо помнить, что каждый из этих входов должен
составляться как самостоятельная подпрограмма, т. е.
содержать команды извлечения адресов фактических
параметров из магазина, заказ на базирование и уста­
новку базы и т. д. Любой такой вход должен оканчиваться
выходом по команде 13, Ш, (либо ей эквивалентной),
выполняющей те же функции, что и фортранный опе­
ратор КЕТИРШ.
В процессе отладки автокодной подпрограммы может
возникнуть необходимость отладочных печатей. Имеется
целая серия системных подпрограмм, позволяющих
удобно осуществлять такую печать.

Для печати текстовой строки (заданной в коде 180)
можно воспользоваться системной подпрограммой
РКШТ8. Обращение к ней является нестандартным
и выглядит так:
```
14, УТМ, <начальный адрес информацию
, 1Т8, 14
14 ■, УТМ, <конечный адрес информацию
-, 1Т8, 14
14 , УТМ, <номер начальной позиции ва АЦПУ>
» 1Т8, 14
» САЬЬ, РКШТ8
```
Нестандартность здесь состоит в том, что последним
засылается на сумматор не адрес номера начальной
позиции, а сам номер начальной позиции. При этом
счет позиций идет от 0, так что роль управляющей
позиции играет нулевая позиция. Не­
обходимо соблюдать осторожность при пользовании
этой управляющей позицией, а еще лучше здесь ею не
пользоваться.
Вместо РИШТ 8 можно использовать подпрограмму
РКШТА со стандартным обращением, аналогичным фортранному оператору САЬЬ РКШТА (АНАЧ, АКОН,
ШОЗ)
Отметим, что за одно обращение к подпрограмме
РКШТ 8 или РКШТА можно отпечатать только одну
текстовую строку, излишек текста печати будет обрезан.
Для печати массива чисел в формате, аналогичном
фортранному формату Е, служит системная подпро­
грамма РКШТЕ. Обращение к ней аналогично форт­
ранному оператору
САЬЬ, РКШТЕ (АНАЧ, АКОН, N. М)
Здесь АНАЧ и АКОН — начальный и конечный
адрес печатаемого массива чисел, N — количество
чисел, печатаемых в одной строке, М — число энаков
после запятой. Массив печатается слева направо по N
чисел в каждой строке, с одним пробелом между числами.
Отметим, что число позиций, отводимых под одно число,
равно М+7,
Печать восьмеричных чисел (аналогично Фортран­
ному формату О) можно сделать о помощью подпро­
граммы PRINTO, обращение к которой аналогично
обращению к PRINTE. При этом должно быть М^16,
Если М < 16, то старшие разряды восьмеричной кон­
станты игнорируются.
Более подробное изложение рассматриваемых во­
просов имеется в 127] (стр, 195—200),

## 21. Некоторые приемы программирования на автокоде

К использованию автокода чаще всего прибегают
в тех случаях, когда возникает необходимость работать
с частями машинного слова. Поэтому в большинстве
таких подпрограмм отдельные операторы производят
упаковку информации, другие — ее распаковку. Поль­
зователю нелишне ознакомиться с некоторыми приемами
упаковки и распаковки.
Упаковку обычно делают так. Сначала заносят
нуль в нужное машинное слово, затем присоединяют
к нему справа очередные разряды путем логического
сложения с предварительным левым сдвигом на соот­
ветствующее число разрядов. При таком способе упа­
ковки слово заполняется слева направо, причем каждый
раз производится левый сдвиг уже упакованной части
слова на столько разрядов, сколько требуется для
очередного фрагмента, располагаемого в младших раз­
рядах слова.
Пример. Пусть надо присоединить справа к ма­
шинному слову РАСК очередные б разрядов, располо­
женные в младших разрядах слова В1Т (остальные раз­
ряды этого слова произвольны). Это можно сделать
такими командами:
, ХТА, РАСК
, А81М, 64-6
, ХТ8, В1Т
, ААХ, =77
15, АОХ,
, АТХ, РАСК
Если упаковку надо производить справа налево, то
очередной фрагмент располагают в старших разрядах
слова и каждый раз производят правый сдвиг на нуж­
ное число разрядов с последующим логическим сло­
жением.

Распаковку удобно производить с использованием
регистра младших разрядов. При распаковке слева на­
право, т. е. начиная со старших разрядов слова, сначала
производится сдвиг влево, затем запись «остатка»
в исходное машинное слово с последующей выдачей
выделенного фрагмента из регистра младших разрядов
в младшие разряды сумматора. При распаковке справа
налево сначала производится сдвиг вправо, затем
запись «остатка» в исходное слово и выдача выделен­
ной части из регистра младших разрядов в старшие
разряды сумматора.
Пример. Пусть надо распаковать 10 старших
разрядов слова БЕР, получив в исходном слове остав­
шиеся младшие разряды, а распакованные разряды —
в слове ШТ в виде целого числа. Указанные операции
можно проделать с помощью такой группы команд:
, ХТА, БЕР
, А8И, 64-10
, АТХ, БЕР
. УТА,
» АОХ, =10
, АТХ, ШТ
В обоих рассмотренных примерах предполагается,
что будет сделано базирование коротких адресов.
Среди арифметических операций известную слож­
ность представляют операции над ненормализованными
(в частности, целыми) числами, особенно умножение
и деление. Последние удобно производить с помо­
щью специальных системных подпрограмм, именуемых
I * МБ * I и I * Б1 * I соответственно. Первый операнд
необходимо поместить в сумматор, а адрес второго зане­
сти в индекс-регистр 14. Например, умножение целого
числа по адресу М на целое число по адресу N можно
осуществить командами
, ХТА, М
14, УТМ, N
, САЬБ, I * МБ * I
Результат умножения, взятый по модулю 240, выдается
на сумматор в виде целого числа. Аналогично можно
производить операции над комплексными величинами
и величинами с двойной точностью (см, [27], стр. 64).

## Заключение

Мы описали практически все
конструкции автокода Madlen по состоянию на 1975 г.
При дальнейшем развитии этого языка не исключено
появление новых конструкций, расширяющих его воз­можности.
Программист, пользующийся автокодом, должен
помнить, что транслятор с автокода выполняет лишь
функции «переводчика» с одного языка на другой. Это
означает, что все машинные операции, которые должны
быть выполнены в подпрограмме, необходимо задать
в виде автокодных команд. Исключение составляет лишь
рассылка данных, выполняемая загрузчиком согласно
указаниям о рассылке. Транслятор с автокода, естест­венно,
требует, чтобы исходная информация, т. е. запись
подпрограммы на языке Madlen, была правильной,
полной (отсутствие неописанных идентификаторов) и
непротиворечивой (отсутствие дважды описанных иден­тификаторов).
Диагностика выдается лишь при нарушении правил
записи операторов на входном языке, а также при явном
несоответствии заданного оператора сути соответствую­щей
команды (например, команды с мнемокодами
VTM, VLM или VJM и пустым указателем индекс-регистра).
