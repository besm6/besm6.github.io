Вычислительный центр АН СССР

С. И. Пирин

Паскаль БЭСМ-6
Руководство по программированию
Версия 2 (15.06.79)

Москва, 1979

---

УДК 681.3.06

Паскаль БЭСМ-6
Руководство по программированию

Описывается язык программирования Паскаль, реализованный на ЭВМ БЭСМ-6.
Объясняется работа с компилятором в рамках системы "Пульт" и в
автономном режиме. Приводится инструкция по использованию редактирующей
программы "Колонки", с помощью которой напечатано данное руководство.

Использовался материал:
Н. И. Вирт - Язык программирования Паскаль (перевод и комментарий
С. Б. Покровского, ВЦ СО АН СССР)

---

1. Введение.

Язык Паскаль, фактически появившийся в 1970 году (PASCAL0 на CDC 6000),
за пять лет завоевал просные позиции среди других распространённых
языков программирования. В настоящее время имеются компиляторы для
машин серий CDC, IBM, DEC SYSTEM, ICL, CII IRIS, UNIVAC, XEROX SIGMA,
PDP, HONEYWELL, BORROUGHS и других. Теперь к этому списку можно
добавить БЭСМ-6.

Язык, разработанный Н. Виртом прежде всего "для обучения
программированию как систематической дисциплине", используется очень
широко в качестве системного языка для математического обеспечения,
а также для решения различных научных и коммерческих задач.

Основными причинами популярности языка на наш взгляд являются
следующие:
1) паскаль разработан на базе Алгола 60,
2) введены естественные стандартные типы данных,
3) введены разнообразные возможности для структурирования данных,
4) введены удобные управляющие структуры, помогающие пользователям
писать программы в "правильном" стиле,
5) почти все элементы языка машинно-независимы,
6) язык очень технологичен для реализации на большинстве ЭВМ,
7) высокая эффективность рабочих программ.

Начав свою жизнь в феврале 1975 года, система Паскаль БЭСМ стала
работать в опытной эксплуатации с начала 1976 года.

2. Обзор языка.

Алгоритмы и машинные программы по существу состоят из двух частей:
описания подлежащих осуществлению действий и описания обрабатываемых
этими действиями данных. Действия задаются так называемыми операторами,
а данные - описаниями и определениями.

Данные представляются как значения переменных. Каждая переменная,
входящая в некоторый оператор, должна быть введена некоторым
описанием переменной, предписывающим этой переменной идентификатор и
тип. Именно тип определяет множество значений, которые может
принимать данная переменная. В паскале тип может быть задан либо
прямо в описании переменной, либо указан <идентификатором типа>,
в последнем случае этот идентификатор должен быть введён явным
<определением типа>.

Базисными являются простые типы данных. Определение такого типа
задаёт упорядоченное множество значений. Среди них можно выделить
определяемые скалярные типы, которые вводят идентификаторы,
обозначающие каждое значение этого множества. Помимо
<скалярных типов>, вводимых определениями, в паскале имеется пять
стандартных простых типов: логический BOOLEAN, целый INTEGER,
литерный CHAR, вещественный REAL и строковый длиной 6 символов
ALFA (три первых типа являются дискретно-упорядоченными). За
исключением логического типа BOOLEAN, значения этих типов
обозначаются не идентификаторами, а соответственно, числами и
литерами, заключенными в кавычки, синтаксически отличными от
идентификаторов. Множество значений литерного типа - это множество
литер кода АЦПУ-128 (имеется также возможность использовать)
кодировки автокода ИТМ и BT и ISO.

Можно также определить новый тип как отрезок некоторого
<дискретно-упорядоченного типа> - указанием наименьшего и
наибольшего значений отрезка.

Сложные типы данных определяются заданием типа их компонент и
указанием способа организации. Способы организации отличаются
механизмами извлечения компонент из переменной сложного типа.
В паскале имеется четыре способа организации данных: организация
в массив, запись, множество и файл.

При организации в массив все компоненты относятся к одному и тому
же типу. Отдельная компонента может быть извлечена селектором
массива, или вычисляемым индексом, тип которого указывается в
определении <типа массива>; <тип индекса> должен быть
<дискретно-упорядоченным>; как правило, это будет тип, определяемый
программистом, или отрезок <дискретно-упорядоченного> типа.
По значению, принадлежащему <типу индекса>, селектор массива выдаёт
значение, имеющее <тип компонент> массива. Таким образом, каждая
<переменная-массив> может рассматриваться как отображение индексного
типа на <тип компонент>. Время выборки не зависит от селектора
(индекса). Поэтома массивы называются структурами данных с
произвольным доступом.

При организации в запись компоненты (называемые полями) могут быть
разных типов. Чтобы можно было установить тип выбираемой компоненты
прямо по тексту программы (без её исполнения), селекторы записей
не содержат вычисляемых значений, а являются идентификаторами,
однозначно определяющими извлекаемую компоненту. Эти идентификаторы
компонент описываются в определении <типа записи>. И в этом случае
время доступа к выбираемой компоненте не зависит от селектора, и
следовательно, записи тоже являются структурами с произвольным
доступом.

<Тип записи> может быть задан как состоящий из нескольких "вариантов".
Это означает, что различные переменные, несмотря на то, что они
описаны как имеющие один тип, могут иметь значениями определённым
образом отличающиеся записи. Различия могут касаться числа и типов
компонент. Вариант, являющийся текущим значением <переменной-записи>,
отмечается в общем (если оно есть) полеЮ называемом <полем признака>.
Как правило, общая часть будет содержать несколько компонент,
включая и поле признака.

Организация во "множество" определяет множество значений, являющихся
множеством всех подмножеств этого базисного типа. Базисный тип
должен быть <дискретно-упорядоченным> типом.

Файл является последовательностью однотипных компонент. Эта
последовательность определяет естественное упорядочивание компонент.
В каждый момент непосредственно доступна только одна компонента;
доступ к другим можно получить последовательным продвижением по
файлу. Файл заполняется последовательным привешиванием новых
компонент к концу файла. Соответственно, определение <типа файла> не
задаёт числа его компонент.

Переменные, заданные явными описаниями, называются "статическими".
Соответствующие описания связывают с переменной некоторый
идентификатор, исполоьзуемый для указания (обращения к) этой
переменной. С другой стороны, переменные могут создаваться некоторым
исполняемым оператором. При таком "динамическом" создании переменных
выдаётся так называемый "указатель" (заменыющий явный идентификатор),
используемый впоследствие для указания на такую переменную. Этот
указатель может быть присвоен другим переменным, именно, переменным,
типа указатель. Каждая <переменная-указатель> может принимать только
значения, являющиеяся указателыми на значения одного и того же
типа Т; говорят, что она "закреплена" за этим типом Т. Она может,
впрочем, получить также значение _NIL, которое не указывает
ни на какую переменную. Поскольку переменные-указатели могут быть
компонентами создаваемых динамически переменных сложных типов,
использование указателей делает возможным представление конечных
графов всей общности.

Основным оператором является оператор присваивания, предписывающий
присваивание только что вычисленного значения некоторой переменной
(или компоненте переменной). Значение некоторой переменной может быть
получено вычислением "выражения". Выражения состоят из переменных,
констант, множеств, операций и функций, производящих действия над
изображёнными величинами и выдающих новые значения. Переменные,
константы и функции либо описываются в программе, либо являются
стандартными объектами. Паскаль содержит фиксированный набор знаков
операций, каждый из которых может рассматриваться как обозначение
для отображения из операндных типов в тип результатов.

Набор обераций подразделяется на четыре группы:
1) "Фрифмтические операции" сложения, вычитания, обращения знака,
умножения и нахождения остатка.
2) "Логические операции" отрицания, дизъюнкции и конъюнкции.
3) "Операции над множествами" - объединение, пересечение, разность.
4) "Отношения" - равенства, неравенства, порядка, принадлежности и
включения (для множеств). Результаты операция отношения принадлежат
к логическому типу. Отношения порядка применимы только к простым
типам.

Оператор "вызова процедуры" вызывает исполнение соответствующей
процедуры (см. ниже). Операторы присваивания и вызовы процедур
являются вирпичиками или компонентами, из которых строятся сложные
операторы, предписывающие посладовательное, выборочное или повторное
своих компонент. Последовательное исполнение операторов задаётся
"составным оператором", условное или выборочное исполнение -
"оператором если (IF)" и "оператором выбора (CASE)", а повторное
исполнение - циклами. <Оператор если> служит для подчинения исполнения
оператора выражению логического типа, а <оператор выбора> делает
возможным выбор между несколькими операторами в соответствии со
значением некоторого селектора. <Цикл с параметром> используется
в случае, если число итераций известно заранее, в остальных случаях
используются <циклы с условием продолжения> или <циклы с условием
окончания>.

Оператор может быть назван некоторым идентификатором, который может
использоваться для обращения к этому оператору. Такой оператор
называется процедурой, а его описание - описанием процедуры. Такое
описание может вдобавок содержать множество <описаний переменных>,
<определения типов> и дальнейшее <описание процедур>. Так описанные
переменные, типы и процедуры могут упоминаться только в пределах
самой процедуры, и поэтому называются "локальными" для данной
процедуры. Их идентификаторы осмыслены только в пределах программного
текста, составляющего описание процедуры и называемого "областью
определённости" этих идентификаторов. Поскольку одна процедура может
быть описана как локальная по отношению к другой, области
определённости могут быть вложены одна в другую. Объекты, описанные
в главной программе, то есть не локальные ни для какой процедуры,
называются "глобальными".

Процедура имеет фиксированное число параметров, каждый из которых
изображается в пределах процедуры некоторым идентификатором,
называемым "формальным параметром". При активации вызова процедуры
каждому параметру, к которому может быть обращение  изнутри процедуры
через соответствующий формальный параметр, должна быть сопоставлена
некоторая фактическая величина. Эта величина называется "фактическим
параметром". Существует три рода параметров: параметры-значения,
параметры-переменные, параметры-процедуры (параметры-функции).
В первом случае фактический параметр является вычисляемым
единственный раз <выражением>. Соответствующий формальный параметр
является локальной переменной, которой присваивается результат
этого вычислений перед исполнением процедуры (или функции). В случае
параметра-переменной, фактический параметр является <переменной>.
Возможно присутствующие индексы вычисляются до исполнения процедуры
(или функции). В случае параметра-процедуры (или параметра-функции)
фактическим параметром является идентификатор процедуры или функции.

<Описания функций> аналогичны <описаниям процедур>. Единственное
отличие заключается в том, что функции выдют результат, тип которого
ограничен простыми типами и должен быть специфицирован в описании
функции. Поэтому функции могут использоваться как составные части
<выражений>. Для устранения побочных эффектов в пределах <тела>
функции следует избегать присваивания нелокальным переменным.

3. Нотация, терминология и лексика.

Для описания синтаксиса используются следующие метасинтаксические
символы: ::= | (* *) [* *] < > ***
Скобки (* *) используются для группирования синтаксических
конструкций. Скобки [* *] обозначают возможное отсутствие
конструкции. Три звёздочки *** обозначают повторение предшествующей
синтаксической конструкции. Остальные метасинтаксические символы
имеют обычное значение.

Базисная лексика состоит из базисных символов, подразделяющихся на
<Буквы>, <Цифры> и <Ограничители>.

<Буква>::=<Все буквы, используемые в коде АЦПУ-128>
<Цифра>::=0|1|2|3|4|5|6|7|8|9

<Ограничитель>::=<Подчёркнутое слово>|<Специальный символ>|<Пробел>

<Подчёркнутое слово>::=_DIV|_MOD|_NIL|_IN|_IF|_THEN|_ELSE|_CASE|_OF|
_REPEAT|_UNTIL|_WHILE|_DO|_FOR|_TO|_DOWNTO|_BEGIN|_(|_END|_)|_WITH|
_GOTO|_CONST|_VAR|_TYPE|_ARRAY|_RECORD|_SET|_FILE|_FUNCTION|_LABEL|
_PROCEDURE|_PACKED|_NOT|_OR|_AND|_PROGRAM

<Специальный символ>:==+|-|*|/|(yena)|&|(not)|=|#|<|>|(lessequal)|
<=|(moreequal)|>=|<>|(|)|[|]|:=|.|,|;|'|@|:

Следующие пары ограничителей эквивалентны:
_BEGIN	_(
_END	_)
_OR	(yena)
_AND	&
_NOT	(not)
<>	#
<=	(lessequal)
>=	(moreequal)

/* !!!
 * (yena) - это символ "перечёркнутое Y"
 * (not) - символ логического отрицания
 * (lessequal) и (moreequal) - соответственно "меньше или равно"
 *	и "больше или равно"
 */

Конструкция
(* <Любая последовательность символов, не содержащая *) > *)
может быть вставлена между любыми идентификаторами, числами
(см. пункт 4) или ограничителями. Она называется комментарием.
Пары (* и *) не употребляются в языке в другом смысле, и их
вхождения в синтаксические описания означают метасимволы.
В комментариях разрешается использовать комментарии.

4. Идентификаторы, числа, строки.

Идентификаторы служат для обозначения констант, типов,
переменных, процедур и функций. В пределах области определённости
некоторого идентификатора, т.е. в процедуре или функции, в которой он
описан, смысл идентификатора должен быть однозначным (см. 10 и 11).

Для сокращения вместо слова идентификатор мы будем использовать
слово ид.

<Ид> ::= <Буква> [* <Буква> | <Цифра> *]***
Длина идентификатора может быть произвольной, но значащими являются
первые 6 литер.

Для чисел, являющихся константами целого типа INTEGER или
вещественного типа REAL, используется обычная десятичная система
записи (см. 6.1.2). Буква E, предшествующая <порядку>, читается
"умножить на 10 в степени".

<Восьмеричные цифры> ::= (* 0|1|2|3|4|5|6|7 *)***
<Восьмеричное целое> ::= (* 0|1|2|3|4|5|6|7 *)***B

<Целое без знака> ::= <Цифра>***
<Вещественное без знака> ::=
<Целое без знака>.<Целое без знака> |
<Целое без знака>.<Целое без знака>E<Порядок> |
<Целое без знака>E<Порядок>

<Число без знака> ::= <Вещественное без знака> | <Целое без знака> |
<Восьмеричное целое>

<Порядок> ::= [* <Знак> *] <Целое без знака>

<Знак> ::= + | -

Примеры: 1 2E5 0.1 3.14 5E-7 1.2E10 17B

Восьмеричное целое позволяет задать только мантиссу числа. Таким
образом, максимальное восьмеричное целое равно 17777777777777B.
Имеется также возможность задать 48-ми битовые константы в
восьмеричном виде, которые считаются целого типа.

<Восьмеричная константа-справа> ::= <Восьмеричные цифры>C
<Восьмеричная константа-слева> ::= <Восьмеричные цифры>T

Например, машинная константа

6400000000000000 эквивалентна 64T, а
7777000077770007 эквивалентна 7777000077770007C.

<Строка> ::= '<Литера>***'

Последовательность литер, заключённых в кавычки, называется строкой.
Длиной строки является количество литер в ней. Строки длиной = 1
считаются типа CHAR. Строки длиной от 2 до 6 - типа ALFA, причём
строки длиной < 6 дополняются справа нулями. Строки длиной более 6
символов можно использовать в языке только в операторе WRITE.
Символ кавычка ' в строках изображается двумя кавычками.

5. Определение констант.

Определение константы вводит некоторый ид как синоним некоторой
константы:

<Ид константы> ::= <Ид>
<Константа> ::= [* <Знак> *]
(* <Число без знака> | <Ид константы> *) | <Строка> | _NIL

<Определение константы> ::= <Ид> = <Константа>

Если <Знак> используется перед идентификатором константы, то данный
идентификатор должен определять целую или вещественную константу.

Примеры:
PI=3.14
KAPPA=1E-4
LST='LISTNG'
MPI=-PI

6. Определение типов данных.

Тип данных задаёт множество значений, которые могут принимать
переменные этого тима, и связывает с этим типом
идентификатор.

<Тип> ::= <Простой тип> | <Сложный тип>
<Определение типа> ::= <Ид> = <Тип>

6.1 Простые типы.

<Простой тип> ::= REAL | ALFA | <Дискретно-упорядоченный>

Тип REAL - это один из стандартных простых типов в языке паскаль.

<Дискретно-упорядоченный> ::= INTEGER | <Индексный тип>
<Индексный тип> ::= CHAR | BOOLEAN | <Отрезок типа> | <Скалярный тип>

6.1.1. Скалярный тип определяет упорядоченное множество значений
с помощью перечисления идентификаторов, которые обозначают значения.

<Скалярный тип> ::= ( <Ид> [* , <Ид> *]*** )

Пример: (ТРЕФЫ,БУБНЫ,ЧЕРВЫ,ПИКИ)

Константа или переменная скалярного типа может быть операндом:
1) Функции ORD, которая преобразовывает значения скалярного типа
в целые значения.
2) Функции SUCC - даёт следующее по порядку значение.
3) Функции PRED - даёт предыдущее значение.
4) Стандартных функций WRITE и WRITELN.

Пример:
_PROGRAM SCALAR
_VAR КАРТА:(ТРЕФЫ,БУБНЫ,ЧЕРВЫ,ПИКИ);
_BEGIN КАРТА := БУБНЫ;
WRITELN(КАРТА, 1=ORD(КАРТА), ЧЕРВЫ, PRED(КАРТА))
_END.

БУБНЫ TRUE ЧЕРВЫ ТРЕФЫ

Внимание! В отличие от Алгола 60, идентификаторы типов (в том числе
и стандартных) не подчёркиваются.

6.1.2. Стандартные типы следующие:

INTEGER - определяет мнощество целых значений от -(2 в степени 40)
до (2 в степени 40).

REAL - рациональные числа приблизительно от 2 в степени -64
до 2 в степени 63.

BOOLEAN - почти эквивалентен скалярному типу (FALSE, TRUE).

ALFA - определяет строку из 6 символов.

6.1.3. Отрезок типа определяет подмножество значений другого
дискретно-упорядоченного типа путём задания наименьшего и
наибольшего значения.

<Отрезок типа> ::= <Константа> .. <Константа>
Первая константа должна быть не более второй.

Пример: БУКВА='A' .. 'Z'

6.2. Сложные типы.
Сложный тип данных характеризуеся типом (или типами) своих компонент
и способом организации. Кроме того, <сложный тип> может содержать
указание о предпочтительном представлении данных. Символ _PACKED,
предшествующий некоторому определению, почти не влияет на значение
программы и является "указанием" компилятору, что память следует
экономить даже ценой некоторой потери эффективности рабочей программы
за счет действий, описывающих доступ к компонентам такого
структурированного значения.

<Сложный тип> ::= [* _PACKED *] <Неупакованный сложный тип>
<Неупакованный сложный тип> ::= <Тип массива> | <Тип записи> |
<Тип множества> | <Тип файла>

6.2.1. Типы массивов.

Каждый <тип массива> есть структура, состоящая из фиксированного
числа компонент; все компоненты имеют один тип, называемый
<типом компонент>. Элементы массивав выбираются по индексам -
значениям, принадлежащим так называемому "типу индекса". Определение
<типа массива> задаёт как <тип компонент>, так и <тип индексов>.

<Тип массива> ::= _ARRAY [ <Тип индекса> [* , <Тип индекса> *]*** ]
_OF <Тип компонент>

<Тип индекса> ::= <Отрезок типа>
<Тип компонент> ::= <Тип>

Если задано N <типов инлексов>, то массив называется N-мерным; его
компоненты выбираются по N индексам.

Примеры:
_ARRAY [1..100] _OF REAL
_ARRAY [ТРЕФЫ..БУБНЫ] _OF (МАМА, ПАПА, СЛУЖАНКА, Я)

6.2.2. Типы записей.

Каждый <тип записи> есть структура, состоящая из фиксированного
числа компонент, возможно, разных типов. Определение <типа записи>
задаёт для каждой компоненты, называемой полем, её тип и
обозначающий это поле идентификатор. Областью определённости этих
"идентификаторов поля" является само определение записи, однако
они доступны также к <выборках поля> (см. 7.2), обозначающих
переменную запись данного типа.

<Тип записи> ::= _RECORD <Список полей> _END
<Список полей> ::= <Общая часть> [*; <Сменная часть>*] |
<Сменная часть>

<Общая часть> ::= <Однотипные поля> [* ; <Однотипные поля> *]***
<Однотипные поля> ::= <Ид поля> [* , <Ид поля> *]*** : <Тип>

<Сменная часть> ::= _CASE [*<Поле признака>:*] <Ид типа>
_OF <Вариант> [*; <Вариант>*]***

<Вариант> ::= <Список меток выбора>: (<Список полей>)
<Поле признака> ::= <Ид>
<Список меток выбора> ::= <Метка выбора> [*, <Метка выбора>*]***
<Метка выбора> ::= <Константа без знака>

Примеры:
_RECORD ДЕНЬ:1..31; МЕС: 1..12; ГОД: INTEGER _END
_RECORD
ИМЯ, ФАМИЛИЯ: ALFA;
ВОЗРАСТ: 0..167;
ЖЕНАТ: BOOLEAN
_END

6.2.3. Типы множеств.

<Тип множеств> определяет множество значений, являющееся множеством-
степенью (множеством всех подмножеств) соответствующего типа
элементов. <Типами элементов> могут быть только индексные типы,
причём ORD(<Максимальнй элемент>) <= 47 и
ORD(<Минимальный элемент>) >= 0. Над каждым <типом множеств>
определены операции:
+	Объединение
*	Пересечение
-	Разность множеств (бинарное дополнение)
_IN 	Отношение принадлежности

<Тип множеств> ::= _SET _OF <Тип элемента>
<Тип элемента> ::= <Индексный тип>

6.2.4. Типы файлов.

Определение некоторого <Типа файла> задаёт структуру, являющуюся
последовательностью однотипных компонент. Число компонент, называемое
"длиной файла", определением не фиксируется. Файл, имеющий 0
компонент, называется пустым. Имеется стандартны тип файла "TEXT",
определяемый как _PACKED _FILE _OF _CHAR. Файлы с типом TEXT
называются текстовыми.

<Тип файла> ::= _FILE _OF <Тип>

Тип элементов файла не может быть файлом. Никакая компонента сложного
типа не может иметь тип файла.

6.3. Типы указателей.

Доступ к описанным в программе переменным (см. 7) можно получить
через их идентификаторы. Они существуют всё время, пока исполняется
процедура (область определённости), в который эти переменные
локальны, и поэтому эти переменные называются "статическими" или
"статически размещаемыми" (в языке PL/1 они называются автоматически
размещаемыми при вызове процедур). С другой стороны, переменные могут
создаваться и динамически, т.е. безо всякой связи со структурой
программы. Эти "динамические" переменные создаются стандертной
процедурой NEW (см. 10.1.2); поскольку они не входят в явные описания
переменных, они не могут быть обозначены именем. Доступ к таким
переменным достигается через "указательные значения" (ссылки),
выдаваемые после создания динамической переменной. Каждый тип
указателя состоит, таким образом, из неограниченного множества
указывающих на однотипные элементы значений. Над указателями
не определено никаких операций, кроме операций отношения.

Указательное значение _NIL принадлежит всем типам указателей;
оно не указывает ни на один элемент.

<Тип указателя> ::= @ <Ид типа>

Примеры определений типов:

ЦВЕТ = (КРАСНЫЙ, ОРАНЖ, ЖЕЛТ, ЗЕЛ, ГОЛУБОЙ, СИНИЙ, ФИОЛ)
ПОЛ = (МУЖ, ЖЕН)
ФОРМА = (ТРЕУГОЛЬНИК, ПРЯМОУГОЛЬНИК, КРУГ)
КАРТА = _ARRAY [1..80] _OF CHAR
КОМПЛ = _RECORD RE, IM: REAL _END
ТЕЛО = (ГОЛОВА, БЮСТ, ТАЛИЯ, БЁДРА, НОГИ, РУКИ)
ЧАСТИТЕЛА = БЮСТ .. ТАЛИЯ
ЛИЦО = _RECORD
	ФАМИЛИЯ, ИМЯ, ОТЧЕСТВО: ALFA;
	ВОЗРАСТ: 1..177;
	ЖЕНАТ: (ДА, НЕТ, ВРАЗВОДЕ);
	_CASE РОД:ПОЛ _OF
		МУЖ: (ВОЕННЫЙ, ЛЫСЫЙ: BOOLEAN);
		ЖЕН: (
			БЕРЕМ: BOOLEAN;
			МЕРКА: _ARRAY [ЧАСТИТЕЛА] _OF INTEGER
		)
_END
НАЦИЯ = _FILE _OF ЛИЦО

7. Описание и изображение переменных.

<Описания переменных> состоят из списка идентификаторов, обозначающих
новые переменные, за которыми помещается их тип:

<Описание переменной> ::= <Ид> [* , <Ид> *]*** : <Тип>

Каждое описание <переменной файла> Ф с компонентами типа Т
подразумевает дополнительное описание так называемой буферной
переменной типа Т. Эта буферная переменная изображается Ф@ и служит
для присоединения к файлу компонент при его заполнении и для
получения доступа к файлу при чтении (см. 7.2.3 и 10.1.1).

Две стандартные переменные INPUT и OUTPUT являются предописанными как
файлы типа TEXT.

Примеры:
X, Y, Z: REAL
U, V: КОМПЛ
I, J: INTEGER
K: 0..9
P, Q: BOOLEAN
ОПЕРАЦИЯ: (ПЛЮС, МИНУС, УМНОЖ)
A: _ARRAY [0..63] _OF REAL
Ц: ЦВЕТ
ЛЮДИ, НЕНАШИ: НАЦИЯ

Изображение переменных обозначают либо всю (полную) переменную, либо
некоторую компоненту переменной, либо переменную, на которую
ссылается некоторый указатель (см. 6.3). Предполагается, что
переменные в примерах последующих глав описаны, как указано выше.

<Переменная> ::= <Полная переменная> | <Частичная переменная> |
<Указуемая переменная>

7.1. Полные переменные.

<Полная переменная> изображается своим идентификатором.

<Полная переменная> ::= <Ид перменной>
<Ид перменной> ::= <Ид>

/* !!!
 * Тут, видимо, пропуск. 7.2 нечитаемо, дальше вплоть до 10.1
 * отсутствуют.
 */

10.1. Стандартные процедуры.

Стандартные процедуры считаются предописанными для программы на
паскале. Поскольку они, как и все стандартные величины, считаются
описанными в охватывающей программу на паскале области определённости,
появление в программе описаний, переопределяющих эти идентификаторы,
не приводит к конфликтам. Ниже следует список стандартных процедур
и пояснения.

10.1.1. Процедуры работы с файлами.

1) PUT(F) привешивает значение буферной переменной F@ к файлу F.
Определено только в случае, когда перед исполнением значение
предиката EOF(F) есть TRUE. EOF(F) сохраняет значение TRUE. Значение
F@ же становится неопределённым.

2) GET(F) смещает текущую позицию файла (головку чтения/записи) на
следующую компоненту и приписывает значение этой компонеты буферной
переменной F@. Если следующей переменной не существует, то значение
EOF(F) становится TRUE, а значение F@ - не определено. Результат
GET(F) определён только тогда, когда перед исполнением
соответствующего вызова EOF(F) = FALSE (см. 11.1.2).

3) RESET(F) возвращает текущую позицию файла в начало файла и
приписывает буферной переменной F@ значение первого элемента F.
Значением EOF(F) становится FALSE, если F не пуст, в противном случае
значение F@ не определено, а значением EOF(F) становится TRUE.

4) REWRITE(F) уничтожает текущее значение F, т.е. в файле F после
REWRITE(F) не остаётся ни одной компоненты. EOF(F) принимает значение
TRUE, так что может начинаться новое заполнение файла.

О стандартных текстовых процедурах WRITE, WRITELN, READ, READLN
см. 10.1.5.

10.1.2. Процедуры динамического размещения.

1) NEW(P) размещает новую переменную V и приписывает ссылку на V
переменной-указателю P. Если тип V есть <Тип записи> с вариантами,
другая форма этой процедуры
2) NEW(P, T1, T2, ..., Tn) может быть использована размещения
переменной со значением признаков Т1, Т2 и т.д.; не рекомендуется
использовать новую динамическую переменную с другими значениями
признаков.
3) DISPOSE(P) и DISPOSE(P, T1, T2, ..., Tn) может быть использована
для указания, что память, выделенная для соответствующей переменной,
на которую ссылается P, можно использовать для других целей.
4) О процедурах SETUP(P) и ROLLUP(P) см. *********

10.1.3. Процедуры преобразования типов.

Пусть А есть <переменная-массив> типа

_ARRAY [M..N] _OF T

и пусть Z есть переменная типа

_PACKED _ARRAY [U..V] _OF T,

где N-M > V-U. Тогда: PACK(A, I, Z) означает:

_FOR J:=U _TO V _DO Z[J]:=A[J-U+I]

UNPACK(Z, A, I) означает:

_FOR J:=U _TO V _DO A[J-U+I]:=Z[J]

Где J обозначает вспомогательную переменную, не встречающуюся
в других частях программы.

Замечание: в версиях компилятора от 8.3 76 вместо этих процедур
реализованы следующие:
1) PCK(A[I], Z) эквивалентно PACK(A, I, Z);
2) UNPCK(A[I], Z) эквивалентно UNPACK(Z, A, I).

Причем поскольку только тип ALFA представляет упакованный массив,
то процедуры работают только для типов ALFA и _ARRAY[M..N] _OF CHAR.

10.1.4. Дополнительные стандартные процедуры языка паскаль БЭСМ-6.

1) EXIT эта процедура эквивалентна оператору перехода на метку перед
последним _END текущей процедуры.

2) MAPIA(I, A) если I это переменная типа INTEGER, например равная
3418, и A - типа ALFA, то после исполнения данной процедуры
переменной A будет присвоено значение '000341'.

/* !!!
 * Имелось ли тут в виду 341 вместо 3418 ?
 */

3) MAPAI(A, I) выполняет действие обратное процедуре MAPIA

4) TNL(A) используется для получения независимых идентификаторов.
Если параметр типа CHAR, например TNL('A'), тогда следующие
TNL(A), где А - это переменная типа ALFA, будут присваивать A
значения '0000A1', '0000A2' и т.д.

5) ГГ(А) где А типа ALFA, эквивалентна следующей процедуре:

_PROCEDURE ГГ(А: ALFA);
_VAR I:INTEGER; T:_ARRAY [0..5] _OF CHAR;
_BEGIN
	UNPCK(T[0], A);
	_FOR I:=0 _TO 5 _DO
		_IF T[I]#'0' _THEN _BEGIN
			_FOR I:=I _TO 5 _DO
				WRITE(T[I]);
			EXIT;
		_END;
	WRITE(T[5])
_END

6) МАРГА(С1, С2) перекодировка из кода АЦПУ-128 в код автокода
ИТМ И ВТ значения типа CHAR из С1 в С2.

7) МАРЯГА(А1, А2) перекодировка из кода АЦПУ-128 в код автокода
ИТМ И ВТ значения типа ALFA из А1 в А2. Если заполнить таблицу
перекодировки соответствущим образом кодами ISO, эти процедуры можно
использовать для перекодировки из ГОСТА в ISO и наоборот.

8) CODE(<Текст автокода>)
Пример: CODE(ПБ76002=). Текст должен начинаться с левой половины и
кончаться одним из следующих символов: = , : @ ;

9) HALT эта процедура эквивалентна выходу из программы.

10.1.5. Процедуры работы с файлами типа TEXT.

1) WRITE: пусть F обозначает файл типа TEXT, P1,...,PN обозначают
так называемые параметры для записи, Е обозначает выражение, M, N
обозначают выражения типа INTEGER.

1.1) WRITE(P1,...,PN) эквивалентно
WRITE(OUTPUT,P1,...,PN)

1.2) WRITE(F,P1,...,PN) эквивалентно
WRITE(F,P1); ...; WRITE(F,PN)

1.3) Параметр для WRITE имеет одну из следующих форм:
Е:M E:M:N E

Где E представляет значение, которое надо записать в файл F, а M и N
это так называемые параметры ширины полей. Если значение Е, которое
может быть числом, литерой, булевским значением, строкой или
скалярным значением, требует для текстового отображения меньше чем
М литер, то слева от полученного текстового изображения приписывается
соответствующее число пробелов. Если М опущено, то используется
соответствующее значение для М по умолчанию. Таблица значений М по
умолчанию:

================================================
| Тип | CHAR | ALFA | BOOLEAN | INTEGER | REAL |
================================================
| M = | 1    | 6    | 6       | 10      | 14   |
================================================

Для строк по умолчанию М равно длине строки. Если М меньше, чем
требуется, то преобразованное значение Е записывается без пробелов
спереди.

N - это длина мантиссы при записи значений типа REAL. По умолчанию
N=4.

Примеры: в случае оператора
WRITE(3.1234567:0:2, 1=1, 3.14:7, 56, 'ПАПА':5, ПИКИ)
в файл OUTPUT запишутся следующие литеры (для наглядности пробелы
изображены звёздочками)

"*3.13E+00**TRUE*3.1400E+00********56*ПАПА**ПИКИ"

WRITELN(P1,...,PN) эквивалентна WRITELN(OUTPUT,P1,...,PN).

WRITELN(F,P1,...,PN) эквивалентна
WRITE(F,P1,...,PN); WRITELN(F);

Последняя процедура записывает в файл F символ "конец строки".

***************************
Стандартная процедура BIND.

Предназначена для ввода информации в текстовый стандартный файл INPUT.
Имеется два способа употребления этой процедуры:

1) Без параметров. В этом случае на терминал выдаётся в качестве
приглашения "-" (знак минус). После ввода информации файл INPUT
будет установлен на первый симвло введённой информации.

2) Можно употребить в качестве параметра к процедуре произвольную
строку символов (длиной не более 60 символов). Тогда в качестве
приглашения для ввода вместо знака минус будет использована данная
строка.

Внимание! Оператор RESET(INPUT) восстанавливает прежнее значение
файла INPUT.

X. Работа с базой данных.
(База данных сделана Н. И. Филипповым. ВЦ АН СССР)

Для работы с базой данных разработаны следующие стандартные
процедуры:

OPEND GETD PUTD DELD

Эти стандартные процедуры позволяют заводить базу данных на
определённом месте, "открывать" её и после открытия засылать (PUTD)
элементы в базу данных, выбирать их из неё (GETD) и исключать их
(DELD).

X1. Заведение базы данных - делается с помощью приказа в системе
пульт типа

БД NEW <Имя массива в пульте>

Этот приказ образует личную базу данных на месте массива пульта.

X2. Открытие базы данных - осуществляется стандартной процедурой
"OPEND" языка Паскаль-БЭСМ. Например, оператор

OPEND('TTT   ');

открывает базу с именем ТТТ.

Х3. Занесение и выборка информации - осуществляется стандартными
процедурами "PUTD" и "GETD".

Синтаксис:

(* PUTD | GETD *) ( <Инф-пара> [* , <Инф-пара> *]*** )
<Инф-пара> ::= <Имя-элемента-в-базе-данных> , <Переменная>

<Имя-элемента-в-базе-данных> ::= <Выражение-простого-типа>

Переменная не может быть файлом.

Примеры:
_FOR I:=1 _TO 10 _DO PUTD(I, I)

Этот оператор занесёт в базу данных, которая должна быть открыта
с помощью стандартной процедуры "OPEND", десять элементов. Т.е.
число 1 под именем 1 и т.д.

После такого оператора в результате выполнения оператора
GETD(7, J) в переменную J будет занесено значение 7.

Пусть переменная была определена как
M: _ARRAY [1..70, 2..7] _OF _RECORD ИМЯ: ALFA; ГОД: INTEGER _END

и некоторая программа присваивает начальные значения этому массиву
записей, а другие программы используют этот массив. Тогда в конце
работы первой программы она выполняет операторы типа

OPEND('БАЗА  '); PUTD('МАС', M)

В то время как использующие программы начинают выполнение с
операторов

OPEND('БАЗА  '); GETD('МАС', M)

X5. Исключение элементов из базы данных осуществляется стандартной
процедурой "DELD". В скобках нужно указать имена исключаемых
элементов. Если, например, нужно исключить элементы с именами,
равными целым значениям от 1 до 10, выполните оператор

_FOR I:=1 _TO 10 _DO DELD(I)

X6. Реакция на ошибки.

Если при работе с базой данных была выявлена какая-либо ошибка, то
выдается диагностическое сообщение о ней и выполнение прекращается.

Например, при переполнении базы данных будет напечатано

ПЕРЕПОЛНЕНИЕ БД
ОШBD= 6

И выполняются операторы

REWRITE(OUTPUT); _BACK 1

11. Описание функций.

Описание функций служит для определения частей программы, вычисляющих
скалярное или указательное значение. Функции активируются вычислением
<Обращений к функции> (см. 8.2), являющихся частями <выражений>.

<Описание функции> ::= <Заголовок функции> <Блок>

Заголовок функции определяет идентификатор, именующий функцию,
формальные параметры и тип функции.

<Заголовок функции> ::= _FUNCTION <Ид> [* (
<Раздел формальных параметров> [* ;
<Раздел формальных параметров> *] ) *] : <Тип функции> ;

<Тип функции> ::= <Ид типа>

Функции могут быть простого или указательного типа. Внутри описания
функции должен быть обязательно оператор присваивания, в левой части
которого стоит имя функции (компилятор не проверяет это условие).
Одно из этих присваиваний определяет значение функции. Вызов функции
может быть рекурсивным.

11.1. Стандартные функции.

ABS(X)     Определяет абсолютную величину Х. Тип Х должен быть REAL
           или INTEGER. Тип результата совпадает с типом Х.
SQR(X)     Вычисляет квадрат величины Х. Тип Х должен быть REAL или
           INTEGER. Тип результата совпадает с типом Х.
SIN(X)    |
COS(X)    |
EXP(X)    | Тип Х должен быть REAL или INTEGER.
LN(X)     | Результат имеет тип REAL.
SQRT(X)   |
ARCTAN(X) |
ARCSIN(X) |

11.1.2. Предикаты.

ODD(X)  Тип Х должен быть INTEGER, результатом
        является (X _MOD 2 = 1)
EOF(F)  Указывает, находится ли файл F в состоянии "конец файла"
        (end-of-file)
EOLN(F) Указывает, находится ли текстовый файл F в состоянии
        "конец строки".

11.1.3. Функции преобразования типов.

ROUND(X) Округляет значение типа REAL в значение целого типа.
TRUNC(X) Отбрасывает дробную часть REAL значения Х и
         преобразует тип в INTEGER
ORD(X)   Преобразует дискретно-упорядоченные типы в тип INTEGER
CHR(X)   X должен быть целого типа, результат (литерного типа) есть
         литера, порядковый номер которой есть Х.

11.1.4. Дополнительные стандартные функции.

CARD(X)  Х должно быть типа множества. Вычисляется можность множества.
MINEL(X) Х должен быть типа множества. Определяется порядковый номер
         минимального элемента множества Х. Если множество пустое,
         то MINEL(X) равно минус единице.

11.1.5. Функции и процедуры для работы с частями слова.

SHIFT(X, СДВИГ) - стандартная функция. Сдвигает значение Х на СДВИГ.
Тип значения, вырабатываемого функцией SHIFT, совпадает с типом
параметра Х.

SEL(X, СДВИГ, ШИРИНА) - стандартная функция. Сдвигает вправо Х на
сдвиг (обязательно положительный!) и логически умножает на строб
битов, равный [48-ШИРИНА..47]. Тип параметра Х - любой, тип
результата - INTEGER.

INS(КУДА, X, СДВИГ, ШИРИНА) - стандартная процедура. Вставляет правые
разряды Х, определяемые в параметре КУДА, в соответствии с параметрами
СДВИГ и ШИРИНА. Тип параметров КУДА и Х - любой.

Параметр ШИРИНА - константа.
         СДВИГ - простая переменная или константа.

12. Программы.

Паскаль-программы имеют вид почти описания процедуры, за исключением
заголовка.

<Программа> ::= <Заголовок программы> <Блок> <Точка>

<Точка> ::= .

<Заголовок программы> ::= _PROGRAM <Ид> [* (
	<Параметры программы> ) *] ;

<Параметры программы> ::= <Параметр программы> [* , <Параметр программы> *]***

<Параметр программы> ::= <Имя внешнего файла> [* =
	<Восьмеричное целое, принадлежащее [100000B..671474B]>
	<Целое принадлежащее [1..32]> *]

<Имя внешнего файла> ::= <Ид>

Идентификатор, следующий за символом _PROGRAM - это имя программы.
Оно не влияет на выполнение программы. Параметры программы - это
список внешних файлов, которые обязательно должны быть описаны
в блоке процедуры. Они служат для указания программе физического
расположения внешних файлов.

Внимание!!! Стандартные файлы INPUT и OUTPUT, приписанные к каждой
программе, не должны встречаться в списке параетров программы.

Если параметр имеет вид "ID= 270001B 3", это означает, что внешний
файл ID размещается в трёх зонах на барабане 27 с 1 зоны. При запуске
программы на счет каждому параметру без такого непосредственного
указания зон, должен соответствовать параметр в приказе "ПАСКАЛЬ"
в списке файлов после символа "/".

Например, программа с заголовком

_PROGRAM T(F, F1=230000B 7, I1,X);

Если текст программы находится в массиве "ВЕТА" системы Пульт,
может быть запущена приказом:

ПАСКАЛ ВЕТА/МАС1 МАС2 МАС3

Тогда система Паскаль свяжет массивы системы Пульт МАС1, МАС2 и МАС3
с файлами программы F I1 X соответственно (см. прил. 2).

При передаче управления программе перед выполнением первых операторов
неявно будут выполнены операторы:

	RESET(INPUT)
	REWRITE(OUTPUT)
и для каждого внешнего файла F
	RESET(F)

Приложение 1. Ошибки во время трансляции.

Эти ошибки в приказах приказах Паскаль и Пас. При нахождении ошибки
печатается сообщение следующего вида:

**ЛЕКСЕМА=NЛ ОШ=NO
IDENT <Имя>  QU

Где NЛ - это номер лексемы в приказе при нахождении ошибки, а NO -
номер ошибки.

Пример: в приказе

ПАСКАЛ БУФ *

(Здесь звёздочка явно "лишняя") будет напечатано

**ЛЕКСЕМА=03 ОШ=02
IDENT БУФ    QU

Говорящее о том, что ошибка обнаружена при разборе третьей лексемы,
что последний идентификатор был БУФ и что номер ошибки 02.

0 должен быть целый параметр
1 после адреса паскаль-программы нет ограничителя
2 после адреса INPUT либо ничего, либо /, либо -
3 нет адреса для INPUT
4 нет либо <Имя дополнения>, либо /, либо -
5 неправильное имя дополнения
6 нет целого параметра
7 нет адреса файла (адрес файла - это либо имя массива системы ПУЛЬТ,
  либо пара из двух чисел, первое из которых указывает направление,
  номер устройства и начальную зону для обмена, а второе -
  длину в зонах).

******************************************************

2. Ошибки при трансляции.

2.1. Ошибки сканера (СКАНЕР)

0 в числе больше 13 цифр.
1 длина строки больше 1500 символов.
2 в строке первая литера после = больше '3'
3 в строке 1 или 3 литера после = больше '7'

5 цифра в восьеричном числе больше 7
6,7 слишком большие числа
8 не цифра после десятичной точки
9 поядок не число
10 порядок больше 18

******************************************************

2.2. Ошибки в списке полей в записи (СПИСПЛ)

-1 нет метки выбора (либо она не константа, либо неправильного типа)
0 нет ид
1 ид уже определён в данной записи
2 нет ":" в конструкции <Однотипные поля>
3 нет _CASE
4 после _CASE должны быть либо поле выбора, либо ид простого типа
5 нет : (двоеточие)
6 нет _OF
7 нет ни ",", ни ":"
8 метка выбора уже была
9 нет )
10 нет (
11 ид поля выбора уже определён в данной записи
12 в конструкции "_CASE <Ид типа> _OF" <Ид типа> отсутствует
13,14 требуется дискретно-упорядоченный тип

******************************************************

2.3. Ошибки в заголовке программы

0 нет символа "_PROGRAM" в начале программы
1 после символа "_PROGRAM" нет имени программы
2 в заголовке нет ";"
3 нет имени внешнего файла
4 адреса внешнего файла должны быть целыми
5 отсутствует символ ")"
6 нет "." в конце программы

******************************************************

2.4. Ошибки в определении типа (ТИП)

-1 нет "_OF" "_SET"
0 тип не годится для базового типа множеств
1 нужен ид
2 ид уже определён

4 нет ")" или ","

13 не константа
14 нет ".."
15 не константа или константа не того типа
16 тип констант не для типа отрезок

19 ид не определён
20 здесь тип файла не разрешён
21,22 требуется простой тип или тип отрезок
23 нет "_END", соответствующего _RECORD
24 после "_ARRAY" нет "["
25 после отрезка типа нет "]"
26 нет "_OF"
28 сейчас индексный тип - это тип отрезок
29 нет "_OF"
33 нет ни "_RECORD", ни "_ARRAY", ни "_FILE", ни "_SET"
40 после "_PACKED" нет подчёркнутого слова

******************************************************

2.5. Ошибки в формальных параметрах (ФОРПАР)

0 не ид и не подчёркнутое слово
1 не то подчёркнутое слово
2 не ид или ид уже определён
3 не "," и не ":"
4 не тот тип
5 нет ")"

******************************************************

2.6. Ошибки в фактических параметрах (ПАРАМ)

0 процедура без параметров
1 пного параметров
2 стандартные процедуры не передаются в качестве параметра
3 стандартные функции не передаются в качестве параметра
4 несоответствие видов параметров
5 несоответствие типов параметров
6 нет ")" или "," или мало параметров

******************************************************

2.7. Ошибки при вызове ствндартных функций (СТФУН)

1 нет ")"
2,3 не тот тип
4 нужен тип REAL
5 нужен тип INTEGER
6,7 здесь REAL нельзя
8 параметр для EOF не файл, либо стандартный файл

******************************************************

2.8. Ошибки при разборе множителя.

0 константа < 0 или > 47
1 не то подчёркнутое слово
2 не константа
3 нет ")"
4 тип не BOOLEAN
5 не тот ограничитель
6 ид не определён
7 ид не переменная, ни константа, ни функция
8 не базовый тип для множеств
9 нет "("
10 нет "]"

******************************************************

2.9. ошибки при разборе терма (ТЕРМ)

Неправильные типы при операции:
1 *
2 /
3 &
4 _DIV или _MOD

******************************************************

2.10. Ошибки при разборе переменной

0 ни поле, ни переменная
1 не поле
2 нет "," или тип у переменной не массив
3 индекс-константа выходит за пределы границы массива
4 не тот тип у индекса

******************************************************

2.11. Ошибки при разборе выражения (ВЫРАЖ)

0 справа от "_IN" может быть множество или ид типа отрезок
1,2 не те типы
3 недопустимая операция со сложными типами

2.12 Ошибки в операторе CASE (CASE)

0 недопустимый тип
1 константы не одного типа
2 две равные метки выбора
3 нет ":"
4 разные типы меток и CASE-выражения
5 нет "_END"
6 нет "_OF"

******************************************************

2.13. Ошибки стандартных процедур

(WRITE WRITELN)

0 параметр ширины поля для WRITE должен иметь тип INTEGER или его
  отрезок
1 нельзя WRITE(INPUT, ...)
2 WRITE
3 WRITE

*****

4 после "=" в ст. проц. NEW или DISPOSE должно быть выражение
  типа INTEGER
5 нет "("
6 должен быть тип указатель
7 нет ")"
8 здесь требуется переменная типа файл
9,16 нет ид или ид не определён
10 нельзя PUT(INPUT)
11 нет переменной
12 не тот тип
13 нет ","
14 нельзя GET(OUTPUT)
15 нельзя REWRITE(INPUT)
17 нельзя RESET(OUTPUT)
18 поле не определено
19 нет константы

******************************************************

2.14. Ошибки в остальных операторах

GOTO	1 после "_GOTO" нет целого
GO	0 после "_GO" нет "_TO"
IF	0 тип выражения не BOOLEAN
	1 нет "_THEN"
WHILE	0 тип выражения не BOOLEAN
	1 нет "_DO"
REPEAT	0 тип выражения не BOOLEAN
	1 нет "_UNTIL"
FOR	1 не ид или ид не определён
	0 неправильный тип для параметра цикла
	2 несовпадение типов параметров цикла и начального значения
	3,4 нет ни "_TO", ни "_DOWNTO"
	5 несовпадение типов параметра цикла и конечного выражения
	6 нет "_DO"
WITH	0 нет переменной
	1 ид не определён
	2 нет ни поля, ни переменной
	3 переменная не типа запись
	4 нет "_DO"
ГР ДИА	0 в операторе присваивания справа константа, не принадлежащая
	  типу отрезок левой части

******************************************************

2.15. Ошибки блока (БЛОК)

0 неправильный символ
1 нет подчёркнутого слова
(CONST)
2 не ид или ид уже определён
3 нет "="
4 нет константы
****
5,6,8,9 нет ";"
7 нет ":"
10 нет ";" после блока
11 нет подчёркнутого слова после блока

13 нет "_BEGIN"
14 нет "_END"
15 нет ":"
16 не ид или ид уже определён
17 ид не тип
18 функции не бывают типа массив, запись или файл

20 после "_PROCEDURE" ид уже описан
21 предописание сделано не на том уровне

24 нет целого
25 нет ни "," ни ";"
26 не было определяющих вхождения

30 этот ид должен быть типа указатель
31 ид не тип
32 здесь тип не может быть типом файла, записи, массива
33 остались неописанные типы указателей
40 был псевдо-комментарий "КО" и были использованы
   стандартные процедуры NEW

******************************************************

Приложение 2. Запуск Паскаль-программ.

Введём некоторые обозначения: под адресом в этом разделе
подразумевается либо массив системы Пульт, либо два восьмеричных
числа, первое из которых задаёт направление, номер устройства
и начальный номер зоны, а второе - число зон.

Для того, чтобы оттранслировать паскаль-программу АДР и запустить
на счет нужно дать приказ

ПАСКАЛЬ АДР

Если при счёте она требует входной файл INPUT:

ПАСКАЛЬ АДР.<АДР ДЛЯ INPUT>

Если вы хотите получить объектные коды и загрузить их в адрес,
например, КОДЫ, дайте приказ:

ПАСКАЛЬ АДР-ЗОНГП КОДЫ

Для того, чтобы их далее выполнить с входным файлом INPUT, нужно дать
приказ

ПАСКАЛЬ .<АДР ДЛЯ INPUT> - ВЫП КОДЫ

2.1. Приказ ПАСКАЛЬ и ПАС

Эти приказы предназначены для задания различных работ системе
Паскаль. В число этих работ входят:

1) Трансляция паскаль-программ в промежуточный код
автокода;
2) трансляция промежуточного кода в объектный код;
3.1) задавая при этом стандартные файлы для INPUT и для OUTPUT;
3.2) задавая при этом необходимые внешние файлы (если программа
работает с внешними файлами);
3.3) задавая режимы печати;
4) и выполняя ещё кое-какие работы.

Общий синтаксис приказов ПАСКАЛЬ и ПАС:

<Приказы ПАСКАЛЬ и ПАС> ::=
	(* ПАСКАЛЬ | ПАС *) [* <Адрес для паскаль-программы> *]
	[* , <Адрес для файла INPUT> *]
	[* _ <Список дополнений> | <Список внешних файлов> *]

<Список внешних файлов> ::= / <Адрес внешнего файла>***

<Список дополнений> ::= <Дополнение>***

<Дополнение> ::=
	ВЫП <Адрес объектной программы, которую надо загрузить
		и выполнить> |
	OUTPUT <Адрес файла OUTPUT> |
	<Режим печати> |
	ПЕЧ (* 1 | 0 *) | НЕТ | НОВ |
	ЗОНГП <Адрес, куда надо загрузить оттранслированную
		программу в кодах> |
	РУКОВОДСТВО | РУКОВ | ЗОНРУК <Адрес текста руков>

<Режим печати> ::= ПП | ППН | ПА | НП

РУКОВОДСТВО или РУКОВ - при этих дополнениях распечатывается
руководство по программированию языка Паскаль-БЭСМ-6. Если у вас
есть текст своего руководства, дайте приказ

ПАСКАЛ- ЗОНРУК <Адрес текста вашего руководства> ПА РУКОВ

ПЕЧ 1   Включение листинга паскаль-программ.
ПЕЧ 0   Выключение листинга паскаль-программ. По умолчанию ПЕЧ 0.

ПП      "Параллельная печать" на терминал и на АЦПУ-128
ППН     "Палаллельной печати нет" - печать только на терминал.
ПА      "Печать на АЦПУ" только.
НП      "Нет печати"

При каждом пакетном запуске системы действует всегда дополнение "ПА".

При пультовом запуске по умолчанию используется дополнение "ППН".

При печати на терминале после определённого количества строк
выдаются символы "ИДТИ<Вопр.знак>" после чего у пользователя есть
три возможности:

а) Дать пустую посылку (т.е. символ ЕТХ) эквивалентно "продолжить
   печатать дальше",
б) дать букву "И" и ЕТХ - т.е. "пропусти текущую выдачу и выполняй
   программу дальше",
в) что-либо другео возвращает управление системе Пульт.

Примеры запуска:

ПАСКАЛЬ ТЕКСТЫ

/* !!!
 * Тут ПАСКАЛЬ с мягким знаком, а дальше вперемешку
 * то с мягким, то без.
 */

т.е. в массиве пульта "ТЕКСТЫ" находится текст паскаль-программы,
которую надо оттранслировать и выполнить.

ПАСКАЛ ТЕКСТЫ.ДАННЫЕ

Данные для файла INPUT при выполнении программы "ТЕКСТЫ" находятся
в массиве "ДАННЫЕ".

ПАСКАЛ ТЕКСТЫ-НЕТ

АРХ ШШШШШШШ

ПАС.ДАННЫЕ

Такая последовательность приказов рекомендуется, если текст
паскаль-программы "ТЕКСТЫ" и данные к ней находятся в разных архивах.

Если вы постоянно упоребляете какой-нибудь паскаль-приказ, например:

ПАСКАЛ ПРОГРАММА.ДАННЫЕ-OUTPUT 320006 12

Вы можете дать приказы:

ПАСКАЛ ПРОГРАММА.ДАННЫЕ-OUTPUT 320006 12 НОВ

и после выдачи сообщения "НОВЫЙ ЗАПУСК ГОТОВ К РАБОТЕ" записать его
в какой-нибудь массив приказом пульта типа:

ЗАП МОЙЗАП(1)

и далее вместо этого длинного приказа давать приказ

МОЙЗАП

***************************************************

Приложение 3. Описание некоторых особенностей языка Паскаль-БЭСМ-6.

3.0 Псевдокомментарии.

Если первой литерой в комментарии является "=", то предполагается,
что далее возможно следует управляющая компилятором информация,
в соответствии с которой он переводит последующий текст программы.
Каждый элемент управляющей информации отделяется друг от друга
запятой и имеет вид:

(* E|L|P|T|C|R|M|D|I *) (* +|- *) |
A(* 0|1|2|3 *) |
B(* 1|2|3|4 *) |
K(* <Целое от 0 до 25> *)

Далее описывается семантика информационных элементов. В скобках
указано значение по умолчанию.

E(E-)
Если указано Е+, то эквивалентная программа для процедур на
языке ассемблера начинается с метки, равной имени процедуры, и
эта метка считается внешней, иначе имя выбирается с помощью
стандартной процедуры TNL.

L(L-)
"L+" перед программой "включает" листинг объектной программы
на языке ассемблера.

P(P+)
Включение улучшенной "посмертной" выдачи.

T(T+)
"Т-" - отмена динамических проверок во время выполнения.

A(A1)
"А1" строковые константы в кодировке АЦПУ-128,
"А0" строковые константы в кодировке автокода ИТМ И БТ,
"А2" (ещё не реализовано) строковые константы в кодировке ISO
	(мониторная система дубна).

C(C+)
"С-" а) Отмена проверки типов во время трансляции
!!!! Внимание! Пункт а) временный.
     б) Организация программ на языке ассемблера в блоки. Для этого
     заголовок процедуры нужно обрабатывать при "С-". Не забудьте
     включить "С+". Максимальное статическое число меток программы
     ассемблера около 2000.

R(R+)
При R+ операции отношения со значениями типа REAL проводятся с
округлением, т.е. два значения типа REAL считаются равными, если
ABS(R1 - R2) < 1.0E-6 * MAX(ABS(R1), ABS(R2))

M(M+)
"М-" убыстряет целочисленное умножение положительныз чисел. В области
его действия нельзя перемножать отрицательные целые числа.

B(B1)
Пусть N - следующая за "B" цифра. Тогда выражение 256*N определяет
приблизительный размер буфера в стеке для последующих переменных
типа файл.

K(K4)
1024*К размер памяти для размещения глобальных переменных, вводимых
процедурой NEW. Разрешается после К указывать целое число <= 25.

I(I+)
В режиме "I+" оператор WTITELN(OUTPUT,....) после записи информации
в файл OUTPUT вызывает немедленный вывод
<число элементов в файле> _MOD 6144 последних символов файла OUTPUT
на АЦПУ или терминал в соответствии с дополнением печати при запуске
программы. После вывода неявно выполняется оператор REWRITE(OUTPUT).

"I-" не вызывает немедленного листинга.

Внимание!!! После отладки программы не забудьте перед программой
вставить псевдокомментарий (*=Т-,Р-*) .

3.1. Использование операторов языка ассемблера в паскаль-программах.

Последовательность операторов ассемблера можно писать внутри скобок
стандартной процедуры "CODE( )". Рекомендуется применять процедуру
CODE только в тех случаях, когда это связано с использованием
особенностей операционной системы ЭВМ БЭСМ-6.

Например, нужно выполнить экстракод 053 (астрономическое время)
и присвоить значение, выработанное этим экстракодом, переменной
ВРЕМЯ. Это делается следующими операторами:

CODE(Э05310=,); ВРЕМЯ:=;

3.2. Стандартные функции для работы с указателями.

Введены стандартные функции для взятия ссылки на переменные (REF),
преобразования значения типа "ссылка" в значение типа INTEGER (ORD)
и наоборот (PTR).

Рассмотренные стандартные функции можно использовать для настройки
указателя на абсолютные адреса. Пусть, например, некоторая программа
считывает оттранслированную паскаль-программу в память, в адрес
600138 заносит некоторое число. Это число паскаль-программа может
записать в "свою" переменную R:

P:=PTR(600138); R:=P@;

Данные функции можно применять для "ручной" оптимизации программ.

Например, вместо операторов
A[I,J,K] := A[I,J,K] + A[I,J,K+1] + A[I,J,K+2];
A[I,J,K+1] := A[I,J,K] + A[I,J,K+2];

Можно написать более эффективные

P = REF(A[I,J,K]);
P1 := PTR(ORD(P1)+1);
P1 := PTR(ORD(P1)+2);
P@ := P@ + P1@ + P2@;
P1@ := P@ + P2@;

3.3. Дополнительные управляющие структуры.

В соответствии с идеями структурного программирования и требованиями
практики в язык введены следующие управляющие структуры:

3.3.0. Оператор SELECT.

Вложенные операторы типа _IF, например,

_IF A _THEN B
_ELSE _IF A1 _THEN B1
_ELSE _IF A2 _THEN B2
_ELSE _IF A3 _THEN B3

Вместо этого оператора можно написать

_SELECT
A:B;
A1:B1;
A2:B2;
A3:B3
_END

Синтаксис:

<Оператор SELECT> ::=
_SELECT <Условный вариант> [* ; <Условный вариант> *]*** _END

<Условный вариант> ::= <Выражение> : <Оператор>

Выражение должно иметь логический тип.

3.3.1. Структурные метки.

Каждый оператор может быть помечен структурной меткой.

<Оператор> ::=
    [* <Метка> : *] [* (<Структурная метка>) *] <Непомеченный оператор>

<Структурная метка> ::= <Идентификатор>

Областью действия структурной метки является непомеченный
оператор.

3.3.2. Оператор EXIT.

В области действия стукрурной метки, например, "(М)", могут быть
управляющие операторы _EXIT M, каждый из которых эквивалентен
выходу из соответствующего структурной метке непомеченного оператора.

Синтаксис:

<Оператор EXIT> ::= _EXIT <Структурная метка>

3.3.3. Оператор GOTO

Синтаксис:

<Оператор GOTO> ::= _GOTO (* <Метка> | <Структурная метка> *)

Операторы GOTO со структурными метками могут находиться только
в области действия структурных меток. Действие аналогично
обычному оператору _GOTO.

3.3.4. Оператор ветвления (BRANCH).

Синтаксис:

<Оператор ветвления> ::= _BRANCH <Выражение> _OF
	<Оператор> [* ; <Оператор> *]*** _END

Семантика.

При передаче управления на оператор ветвления вычисляется
<Выражение>, которое должно быть простого типа, далее управление
передаётся на первый оператор в ветке. Если J-ый оператор ветки
закончился, то происходит выход из ветки и управление передаётся
за _END. При исполнении J-го оператора может быть выполнен оператор
_BACK.

Синтаксис оператора _BACK:

<Оператор BACK> ::= _BACK <Выражение>

При выполнении оператора BACK вычисляется выражение и находится
наиболее динамически предшествующая ветка с совместимым значением
выражения. Значения совместимы, если либо они равны, либо одно из
них равно нулю.

После нахождения такой ветки управление передаётся следующему
в ветке оператору, либо, если выполнялся последний оператор,
за _END ветки.

Внимание! В операторе ветвления нельзя использовать обычные целые
метки и обычные операторы _GOTO <Целое>. Пользуйтесь структурными
метками и операторами EXIT и GOTO.

Если не найдётся ветки с совместимым выражением, то считается,
что программа заключена в оператор

_BRANCH <Программа>; _BEGIN <Вывод текста "Выход по ALT"> _END _END

Пример. Приведём следующую программу и её результат:

_PROGRAM T;
_VAR B: BOOLEAN;
_PROCEDURE M(I: INTEGER);
_BEGIN
	(И) _BRANCH I _OF
		_BEGIN
			_IF(I<20) _THEN
				M(I+1)
			_ELSE
				_EXIT И;
			_BACK I-2
		_END;
		WRITELN(I)
	_END
_END;
_BEGIN
	B:=FALSE;
	(MM) _BEGIN
		_IF _NOT B _THEN _EXIT MM;
		EXIT
	_END;
	WRITELN('(MM)');
	M(0)
_END.

(MM)
        17
        14
        11
         8
         5
         2
         0
ВСЁ СДЕЛАНО.

Приложение 4. Листинги паскаль-программ.

Приведём программу, которая раньше печатала руководство.

/* !!!
 * Символ '=' внутри строк обозначает символ
 * "три горизонтальных черты".
 * Символ "перечёркнутая Y" заменён на свой эквивалент _OR.
 *
 * Идентификаторы (имена переменных и функций) там, где это
 * возможно, вбиваются латиницей.
 * Например, KC, KT, HC - латиница;
 * ЧИССТР - кириллица.
 */

(*=B2,I- ЧИСЛО ЛИТЕР В БУФЕРЕ ДЛЯ Х ИЛИ Y ПРИБЛИЗИТЕЛЬНО
РАВНО 2*256*6=3072
*****************************************)

(*ВЕРСИЯ 7.7.76*)

_PROGRAM СТОЛБЕЦ;
_CONST
	ДЛСТР=56;
	ЧИССТР=51;
	KC='=175';
	KT='=172';
	HC='=141';
_TYPE
	БУКВА='A'..'Z';
_VAR
	X,Y: TEXT;
	L,I: INTEGER;
	KOH,BHC,B: BOOLEAN;
	C: CHAR;

_PROCED ЗАПСТР(_VAR X: TEXT);
_VAR
	I: INTEGER;
_BEGIN
	_IF _NOT (BHC _OR KOH) _THEN _BEGIN
		C:=KC;
		_FOR I _TO ДЛСТР _DO
			_IF (INPUT@=KT)_OR(INPUT@=KC)_OR(INPUT@=HC) _THEN
				I:=200
			_ELSE _BEGIN
				X@:=INPUT@;
				C:=;
				GET(INPUT);
				PUT(X)
			_END;
		KOH:=INPUT@=KT;
		BHC:=INPUT@=HC;
		_IF _NOT KOH & (I=201) _THEN
			GET(INPUT)
		_ELSE _IF INPUT@ _IN ['+'..'@', ')'..';', '*'..'#', '>'..':' ] _THEN _BEGIN
			WRITE(X, INPUT@);
			GET(INPUT)
		_END _ELSE _IF (INPUT@ _IN БУКВА) & (C _IN БУКВА) _THEN
			WRITE(X,'-')
	_END;
	X@:=KC;
	PUT(X)
_END;

_PROCED PAGE(_VAR X: TEXT);
_BEGIN
	BHC := FALSE;
	REWRITE(X);
	WRITELN(X, ' =174=024- ', L:0, ' -');
	WRITELN(X);
	_FOR I _TO ЧИССТР _DO
		ЗАПСТР(X)
_END;

_PROCED ШТР;
_BEGIN
	WRITELN('-=174=176');
	WRITELN;
	WRITELN;
_END;

_PROCED ПЕЧАТЬ;

	_PROCED ПЕЧ(_VAR X: TEXT);
	_BEGIN
		_WHILE X@#KC _DO _BEGIN
			OUTPUT@:=X@;
			PUT(OUTPUT);
			GET(X);
		_END;
		GET(X);
	_END;

_BEGIN
	ШТР;
	RESET(X);
	RESET(Y);
	_FOR I _TO ЧИССТР+2 _DO _BEGIN
		WRITE(' ':3);
		ПЕЧ(X);
		WRITE('=173=105');
		ПЕЧ(Y);
		WRITELN;
	_END;
	(*=I+*)
	WRITELN;
_END;

_BEGIN
	L:=1;
	KOH=FALSE;
	WRITELN('ПАСКАЛЬ-ПРОГРАММА ЛИСТИНГ В ДВЕ КОЛОНКИ':80);
	_REPEAT
		B:=TRUE;
		_REPEAT
			_IF B _THEN
				PAGE(X)
			_ELSE
				PAGE(Y);
			L:=L+1;
			B:=_NOT B;
		_UNTIL B;
		ПЕЧАТЬ
	_UNTIL КОН;
	ШТР
_END.

Приложение 5.
Инструкция по пользованию программой "Колонки" (версия от 15.01.80)
для автоматического редактирования и распечатки текстов
в две колонки.

а) Для того, чтобы воспользоваться программой "Колонки", нужно поместить
текст в массиве системы Пульт или просто начиная с некоторой зоны.
Затем дать приказ:

ПАСКАЛЬ-ПА ЗОНРУК <Адрес> РУКОВ

Здесь <Адрес> - это либо имя массива системы Пульт, либо
ННЗЗЗЗ <Число зон текста>
где
    НН - номер направления
    ЗЗЗЗ - начальный номер зоны.

б) 1. Текст должен состоять из литер, закодированных в коде АЦПУ-128.

2. Два мягких знака определяют вместе с последующим за ними символом
управляющий символ. Имеются следующие управляющие символы:

  2а. "Н" (либо символ с кодом 175В) - символ новой строки;

  2б. "Л" (141В) - символ начала страницы;

  2в. "Е" (172В) - символ конца текста;

  2г. "И" (143В) - если далее следует символ "0" (ноль), то это отмена
      переноса идентификаторов. При другом символе включение
      программы переноса.

  2д. "З" (144В) - "заголовок". этот символ начинает новую строку,
      которую пытается поместить посередине строки.

  2е. "К" (142В) - После символа "К" следует литера, указывающая,
      с какой позиции начинать строку.

  2ж. "М" (146В) - после символа "М" следует цифра, определяющая
      число прогонов бумаги после новой строки.

  2з. "MN" - включение нумерации строк.

  2и. "ML" - после "L" следует литера, код которой указывает, сколько
      строк следуетразмещать на странице (по умолчанию на странице
      размещается 58 строк).

  2к. "MC" - после "С" следует десятичное число, указывающее номер
      начальной страницы.

  2л. "MB+" - включение выравнивания правой стороны страницы
      (выключки строки).

  2м. "MB-" - отключение выравнивания.

  2н. "MM+" - оключение "монолита". При включенном монолите правило
      переноса применяется к словам, состоящим из любых символов.

  2о. "MM-" - отключение монолита.

  2п. "-" - отключает печать.

  2р. "+" - включает печать.

Примечание. Управляющие комбинации, содержащие знак "+",
считаются, по умолчанию, стоящими в начале текста.

в) Повторяющиеся символы можно запаковывать:

Пробелы - литерой с кодом 200В+<Число пробелов>;

Произвольные литеры - тройкой литер:

"Литера", либера с кодом 174В, литера с кодом, равным числу
повторений без единицы.

3. Любой текст можно сжать, используя коды программы СЖАТЬ.
Приведём эту программу:

(*=P-,T-*)_PROGRAM COMPRESS;
_CONST
	ПОВТ='=174';
	СИМКОН='=172';
	КОНЕЦ='=172=175';
	MAX=120;
_TYPE
	LIT='A'..'Z';
_VAR
	C:CHAR;
	I:INTEGER;
_(
	_REPEAT
		C:=INPUT@;
		GET(INPUT);
		_SELECT
			C=СИМКОН:
				_(
					ГГ(КОНЕЦ);HALT
				_);
			(C=INPUT@)&(C<CHR(140B)):
				_IF C=' ' _THEN _(
					I:=1;
					_WHILE INPUT@=' '_DO
					_(
						I:=I+1;GET(INPUT)
					_);
					_WHILE I>MAX_DO_(
						WRITE(CHR(200B+MAX));
						I:=I-MAX
					_);
					WRITE(CHR(200B+I))
				_) _ELSE _IF _NOT(C_IN LIT)_THEN _(
					I:=1;
					_WHILE INPUT@=C_DO_(
						I:=I+1;
						GET(INPUT)
					_);
					_WHILE I>MAX_DO_(
						WRITE(C,ПОВТ,CHR(MAX));
						I:=I-MAX
					_);
					WRITE(C,ПОВТ,CHR(I-1))
				_) _ELSE
					WRITE(C);
			TRUE:
				WRITE(C)
		_)
	_UNTIL FALSE
_).

Приложение 6. Запуск компилятора Паскаль-БЭСМ в автономном режиме
(без использования системы Пульт).

Для запуска необходимо переписать в ВЦ АН СССР системную ленту
паскаля (всего 60 зон).

6.1. Паспорт.

ШИФР ХХХХХХ
ВРЕМ ВВ
ЛЕНТ 30(ХХХХ)          СИСТЕМНАЯ ЛЕНТА ДЛЯ ПАСКАЛЯ
ВХОД 10
ЛИСТ 0-25,33-37        При желании можно заказать все листы.

ТРАК 20                Количество трактов, конечно, зависит
                       от размеров вашей программы.
Е

При диалоговой работе естественно необходим раздел "ТЕЛЕ ".

6.2. Карты запуска.

В 00 000 0010
  00 000 0000

К 02 24 Т00ХХ      см. разд. 6.4
  00 070 0011

К 00 010 0000
  00 030 0033

Эти карты, как и карты приказа Паскаль, необходимы при любом запуске.
Второй регистр при запуске содержит управляющую пакетным запуском
информацию:

6.3. Карты приказа паскаль.

Приказ паскаль вводится с адреса 72000В.

Например:
В 00 007 2000
  00 000 0000

А1

ПАСКАЛЬ 270000 15 . 260000 4

6.4. Признаки Т и ХХ для второго индекс-регистра.

Т=4	Требуется диалоговый режим с терминалом.

Т=0	Работа без диалога.

ХХ=20	Тогда система считает, что ваша программа размещена
	с адреса 2000В, а данные к ней с адреса 40000В.

	Длина программы не более 4 зон, длина данных не более
	одной зоны.

	Паскаль-приказ:

	ПАСКАЛ 270000 4 . 260000 1

	Естественно с возможными дополнениями.

ХХ=40	Почти то же самое, но длина программы не более 13 зон,
	длина данных не более 4 восьмеричных зон.

ХХ=00	В этом случае система считает, что информации в памяти нет,
	и она начинает выполнение паскаль-приказа.

ХХ<17В	"Старый запуск" паскаль программа расположена с адреса 2000В.
	Данные могут быть приклеены к ней.

6.5. Примеры карт.

1) На системной ленте расположен текст программы "СЕРВИС" пульта,
составленный автором И. С. Фойгелем из ИРЭ АН СССР. Он записан на
двух зонах, начиная с 60(8) зоны. Для его трансляции и счеёта
необходимо ввести следующие карты:

ШИФР ХХХХХХ
ВРЕМ 30
ЛЕНТ 30(ХХХХ)
ВХОД 10
ЛИСТ 0-25,33-37
ТРАК 30
ТЕЛЕ
Е

В 00 000 0010
  00 000 0000

К 02 24 40000
  00 070 0011

К 00 010 0000
  00 030 0033

В 00 007 2000
  00 000 0000

А1

ПАСКАЛ 300060 2-ПП

_

ЕКОНЕЦ

2) Пример пакета для решения паскаль-программы с данными
не в диалоговом режиме.

ШИФР ХХХХХХ
ВРЕМ 20
ЛЕНТ 30(ХХХХ)
ВХОД 10
ЛИСТ 0-25,33-37
ТРАК 20
Е

В 00 000 0010
  00 000 0000

К 02 24 00000
  00 070 0011

К 00 010 0000
  00 030 0033

В 00 00 72000
  00 000 0000

А1

ПАСКАЛЬ 270000 5 . 260000 1

_

В 00 000 2000
  00 000 0000

А1

PROGRAM T;
_BEGIN  WRITELN('Я РАБОТАЮ.') _END.

_

C 0000 0000
  0000 0172

B 00 00 40000
  00 000 0000

A1

Место для данных паскаль-программы

_

ЕКОНЕЦ

Приложение 7. Инструкция по использованию предопределённых описаний
процедур и типов данных.

7.1. Предопределение процедур.

_PROCEDURE A;
_BEGIN
	B(2);
_END;
_PROCEDURE B(T: INTEGER);
_BEGIN
	A
_END;

Последовательность процедур подобного рода со взаимными ссылками
в версии компилятора паскаль на ассемблер чайковского должна быть
прописана в виде:

_PROCEDURE B(T: INTEGER);+
_PROCEDURE A;
_BEGIN
	B(2);
_END;
_PROCEDURE B(T: INTEGER);
_BEGIN
	A
_END;


7.2. Предопределение типов.

Если при определении типа данных встречается ещё не определённый
идентификатор типа, то он считается идентификатором типа указатель
и должен быть определён в том же разделе определения типов.

Пример:

_TYPE
	T=_RECORD
		B: UBTEGER;
		P: УКАЗАТЕЛЬ
	_END;
	УКАЗАТЕЛЬ= @T;

Приложение 8. Новые возможности в системе Паскаль-автокод.

8.1. Базирование.

Комментарий (*=Х+*), поставленный в начале программы, указывает на
необходимость базирования программы. Базированные программы
можно загружать и исполнять с любого адреса.

В директиве паскаль добавлено новое дополнение (после знака минус);
ЛИСТ <Восьмеричный номер листа>.

Например, приказ

ПАСКАЛЬ-ВЫП МАС ЛИСТ 4

загружает базированную готовую программу "МАС" на 4-й лист
и выполняет их.

8.2. Сегментация.

Включена возможность описывать внешние процедуры/функции, далее
загружать их, выполнять и разгружать.

Пример:
Следующую программу транслируем и загружаем ЗОНГП 260000 1.

(*=T-,P-,X+ ПРОГРАММА БАЗИРОВАНА*)
_PROGRAM SEGM;
_PROCEDURE PINT; EXTERNAL;
(* ТЕЛО ПРОЦЕДУРЫ НЕ ОПИСАНО В ДАННОЙ ПРОГРАММЕ *)

(*=E+*)
_PROCEDURE P26;
(*=E-*)
(* ПРОЦЕДУРА Р26 БУДЕТ ВЫЗВАНА ИЗ ДРУГОЙ ПРОГРАММЫ *)
_BEGIN
	WRITELN('РАБОТАЕТ Р26. ВЫЗЫВАЕМ PINT');
	PINT;
	WRITELN('ВЕРНУЛИСЬ ИЗ PINT');
_END;
_BEGIN
_END.

Далее транслируем и выполняем следующую программу:

(*=T-,P-,X+*)
_PROGRAM TEST;
_VAR
	I: INTEGER;
_PROCEDURE P26; EXTERNAL;
(*=E+*)
_PROCEDURE PINT;
(*=E-*)
_(
	WRITELN('РАБОТАЕТ PINT');
_)
_PROCEDURE LAD(НУ3333, АДРЕС: INTEGER);
_(
	АДРЕС := АДРЕС;
	CODE(УИ14=);
	НУ3333 := НУ3333;
	CODE(15ПВLOAD=,);
_);

_(
	WRITELN('ЗАГРУЖАЕМ SEGM НА 7 ЛИСТ С 260000');
	LAD(260000B,16000B);
	WRITELN('ЗАГРУЗИЛИ. ТЕПЕРЬ ВЫПОЛНЯЕМ Р26');
	P26;
	WRITELN('ВЫПОЛНИЛИ Р26');
	CODE(15ПВUNLOAD=,);
	WRITELN('УБРАЛИ ССЫЛКИ НА ПОСЛЕДНЮЮ ЗАГРУЖЕННУЮ ПРОГРАММУ');
_).

Исполнение программы TEST вызовет следующую выдачу:

ЗАГРУЖАЕМ SEGM НА 7 ЛИСТ С 260000
ЗАГРУЗИЛИ. ТЕПЕРЬ ВЫПОЛНЯЕМ Р26
РАБОТАЕТ Р26. ВЫЗЫВАЕМ PINT
РАБОТАЕТ PINT
ВЕРНУЛИСЬ ИЗ PINT
ВЫПОЛНИЛИ Р26
УБРАЛИ ССЫЛКИ НА ПОСЛЕДНЮЮ ЗАГРУЖЕННУЮ ПРОГРАММУ

Программу можно загрузить также в стек:

I:=НУ3333; CODE(17ПИ14=15ПВLOAD,);




****************************************

Содержание:

1. Введение
2. Обзор языка
3. Нотация, терминология и лексика
4. Идентификаторы, числа, строки
5. Определение констант
6. Определение типов данных
7. Описание и изображение переменных
8. Выражения
9. Операторы
10. Описание процедур
11. Описание функций
12. Программы

Приложения:
1. Ошибки во время трансляции
2. Запуск паскаль-программы
3. Описание особенностей языка Паскаль-БЭСМ
4. Листинги паскаль-программ
5. Инструкция по пользованию программой "Колонки"
6. Запуск компилятора Паскаль-БЭСМ в автономном режиме
7. Инструкция по использованию предопределённых описаний
   процедур и типов данных
8. Базирование и сегментация программы
