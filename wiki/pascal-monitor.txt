Академия Наук СССР
Вычислительный Центр

С. И. Пирин

Язык Паскаль-Монитор и его использование

Версия 2.0.

Москва, 1980

* * *

УДК 519.685

Язык Паскаль-Монитор и его использование

Данная работа содержит описание особенностей языка Паскаль-Монитор,
реализованного в рамках мониторной системы "Дубна" на ЭВМ БЭСМ-6.
Рассматриваются правила эксплуатации системы Паскаль-Монитор,
приводятся примеры программ.

* * *

Содержание.

Предисловие

1. Описание особенностей языка Паскаль-монитор
1.1. Словарь
1.2. Псевдокомментарии
1.3. Заголовок программы
1.4. Дополнительные возможности при описании констант
1.5. Стандартные имена
1.6. Процедура записи в файл
1.7. Процедуры чтения из файла
1.8. Определение и реализация стандартных процедур размещения динамических переменных
1.9. Дополнительные управляющи операторы
1.10. Раздельная компиляция программ
1.11. Присваивание констант рассылкой
1.12. Использование предопределений
1.13. Расширение оператора цикла
1.14. Расширение оператора MOD
1.15. Определение типа массива

2. Эксплуатация системы Паскаль-монитор

2.1. Трансляция паскаль-программ в модуль загрузки
2.2. Выполнение паскаль-программ
2.3. Работа сервисной системы PASHELP
2.4. Организация диалога
2.5. Совместное исполнение модулей
2.6. Утилиты для системы Паскаль-монитор

Заключение
Список литературы
Дополнение

* * *

Предисловие.

В данной работе рассматривается язык Паскаль-Монитор, реализованный
для ЭВМ БЭСМ-6 в рамках мониторной системы "Дубна" в вычислительном
центре АН СССР.

В настоящее время язык Паскаль, реализованный для большинства
современных ЭВМ /RIC 76/, используется для решения широкого класса
задач: системного программирования, научно-технических,
экономических, а также для обучения программированию. В США и Европе
имеются специальные центры по распространению языка Паскаль.

В работе определяются дополнительные конструкции по отношению
к стандартному языку Паскаль /JEN 74/. В язык Паскаль-Монитор,
например, введёны стандартные процедуры для связи с системой
МАРС-6 /ФИЛ   /, разработанной в ВЦ АН СССР В. И. Филипповым,
позволяющие обмениваться информацией между различными системами
программирования (Паскаль, Алгол, Фортран, Лисп, Ассемблер)
и организовывать различные информационные структуры во внешней
памяти.

Использование упакованных типов данных (массивов, записей, файлов)
"расширяет" оперативную и внешнюю память ЭВМ БЭСМ-6. Например,
разрешается объявлять упакованные массивы из логических значений
размером от нуля до миллиона.

В работе рассматриваются вопросы эксплуатации системы: трансляция и
выполнение программ, организация диалога между пользователем и
задачей, совместное исполнение Паскаль и Фортран программ. Описаны
некоторые полезные подпрограммы из системной библиотеки. Определяется
специальный сервисный язык для управления трансляцией и выполнением
программ.

1. Описание особенностей языка Паскаль-Монитор.

Основным критерием при разработке версии языка Паскаль-Монитор
для мониторной системы "Дубна" являлось требование максимальной
совместимости с языками уже работающих компиляторов. Были учетены
реализации:
- Паскаль-автокод для ЭВМ БЭСМ-6 /ПИР 78/,
- Паскаль для CDC-6000 /JEN 74/,
- Паскаль для CDC-3300 из Братиславы /ШУС 74/.

Кроме того, было решено, чтобы Паскаль-Монитор полностью включал
в себя стандартную версию языка /JEN-74/.

Были устены особенности мониторной системы "Дубна":
- присваивание значений переменным во время загрузки программы
  с помощью механизма данных и рассылок,
- возможность связи переменных с "общими" областями памяти,
- раздельная компиляция программ на языках Паскаль и Фортран
  и их совместное исполнение,
- разработан интерфейс между Паскаль и Фортран модулями.

В данном разделе будет в основном приведено расширение языка
по сравнению со стандартной версией /JEN-74/.

1.1. Словарь.

Список зарезервированных слов дополнен словом SELECT (перебирать).
Зарезервированные слова не выделяются никакими специальными
символами, хотя перед зарезервированным словом или идентификатором
может стоять символ "_" (подчёркивание), который игнорируется.

В соответствии с требованием стандартного языка первые восемь литер
являются значащими в зарезервированных словах и идентификаторах.

В идентификаторах возможно использование букв русского и латинского
алфавитов.

Следующие ограничители языка эквивалентны:

BEGIN        _(
END        _)
>=        (символ больше или равно)
<=        (символ меньше или равно)
<>        (символ не равно)
OR        (символ дизъюнкции)
AND        (символ конъюнкции)
NOT        (символ логического отрицания)
(стрелка вверх)        (надчерк) и код 100В
DIV        (символ деления)

1.2. Псевдокомментарии

Комментарии в языке Паскаль-Монитор могут состоять из произвольных
символов (кроме комбинации "*)"), располагаться на нескольких
строках. Комментарий начинается символами "(*" (скобка, звёздочка)
и заканчивается парой "*)".

Если первой литерой комментария является литера "=", то
предполагается, что далее следует управляющий компилятором список
режимов, в соответствии с которыми переводится последующий текст
исходной программы. Такие комментарии мы будем называть
псевдокомментариями. Каждый управляющий режим отделяется друг
от друга запятой (пробелы недопустимы!) и имеет вид:

(E|P|T|C|R|M|Y|U|Z|F)(+|-)|D  |A  |K  |B  |S  |L
                            ND  NA  NK  NB  NS  NL

Где всякое N>=0, и ND<=7, NA<=3, NK<=23, NB<=4, NS<=9, NL<=3.

Далее описывается семантика управляющих режимов. В скобках указано
значение по умолчанию.

E(E-) Позволяет указывать программисту процедуры/функции, к которым
      возможно обращение из внешних программ. При Е+ информация
      об идентификаторе (см. также режим "S" в данном разделе)
      и начале кода процедуры/функции заносится в таблицу
      дополнительных входов. Инз-а ограничения на количество
      дополнительных входов модуля загрузки мониторной системы
      "Дубна" их число не должно превышать 18. См. также раздел
      "Раздельная компиляция программ".

P(P+) "Р+" перед обработкой составного оператора процедуры/функции
      сообщает компилятору, что для данной процедуры/функции
      необходимо необходимо хранить во время счёта идентификаторы
      процедуры/функции и локальных переменных простых типов.
      В случае аварийной ситуации выдаётся авостная выдача,
      содержащая:
      - Значения локальных переменных, выполняемых процедурой/
        функцией в соответствии с обратным порядком их вызовов.
      - Идентификаторы вызванных процедур/функций и номера строк,
        в которых начинаются соответствующие составные операторы.
        Информация выдаётся, начиная с "верхушки" стека вплоть до
        значения переменных основной программы.
      Рассматриваемую авостную выдачу можно получать в любой момент
      выполнения программы, см. разд. 2.6.

T(T+) "T-" - отмена динамических проверок во время выполнения.
      Для экономии времени и памяти псевдокомментарий (*P-,T-*)
      желательно ставить для каждой отлаженной программы.
      В режиме "Т+" проверяются:
      а) все индексные выражения на принадлежность к индексному типу;
      б) значения правых частей операторов присваивания, если тип
         левой части является типом отрезка и тип правой части
         не совпадает с типом левой;
      в) значение селекторов операторов выбора на соответствие с
         одним из указанных значений меток выбора.

      При выявлении неправильности печатается строка "OVERRANGE IN",
      порядковый номер исходного текста, и управление передаётся
      стандартной процедуре "HALT", которая, если программа
      транслировалась в режиме "Р+", вызывает внешнюю процедуру
      печати авостной выдачи "PASPMD" и останавливает выполнение
      программы.

      При Т+, если не было управляющего режима S7, проверяется
      правильность значения указателя при взятии ссылки, при неверном
      указателе выдаётся диаграмма
        POINTER OVERRANGE IN <Номер строки>
      и переход на подпрограмму HALT.

      Если в программе используются "нестандартные" функции PTR
      или REF, то всегда следует выполнять программу с
      псевдокомментарием (*=S7*).

C(C-) При "С-" прекращается проверка компилятором соответствия типов
      данных. Ответственность за возможные ошибки возлагается на
      пользователя. В практике использования компилятора
      Паскаль-Монитор данный режим употребляется для работы с
      динамическими массивами.
      Режимом "С-" пользоваться не рекомендуется.

R(R+) При "R+" все операции отношения с вещественными значениями
      производятся с округлением, т.е. два значения В и В1 типа REAL
      считаются равными, если
      |B-B1|<=L*MAX(|B|,|B1|)
      где множитель L расположен в общей ячейке памяти, именованной
      PASFUZZ.
      В начале работы L присваивается значение 1.0E-6, которое можно
      заменить на требуемое соответствующим оператором присваивания
      (см. "Заголовок программы").

M(M+) Данный управляющий режим используется для отпимизации умножения
      целых чисел. "М-" можно ставить только тогда, когда
      пользователь уверен, что сомножителями для целого умножения
      будут только положительные числа.
U(U+) При "U+" (U-) все литеры с 73 (121) позиции на строке исходного
      текста до конца строки считаются комментарием. Обратите
      внимание на недопустимость превышения максимальной длины строки
      (130), которую может обрабатывать компилятор.
Y(Y-) При "Y-" не разрешается использование некоторых не очень
      "правильных" конструкций языка, оставшихся для совместимости
      с языком Паскаль-Автокод. Запрещается:
      - использование конструктора неупакованной записи, т.е.
        комплексной переменной COMP, например, можно в режиме "Y+"
        присваивать значения оператором вида
          COMP:=[3.14,5.12E-2];
        использование пустой правой части оператора присваивания типа
        А:=; (присваивание сумматора). Если конец программы
        транслируется в режиме "Y+", то после компиляции выдаётся
        информация о структуре объектного модуля.

        При Y+ после трансляции выдаётся структура объектного модуля
        в виде
          N > LINES STRUCTURE 1 NDEN 0 0 NDN NCODE 0 NCONST NDATA NREF
        где все размеры в словах и
        NDEN - длина таблицы обозначений модуля,
        NDN - длина таблицы значений идентификаторов,
        NCODE - длина кодов,
        NCONST - длина констант,
        NDATA - длина констант, рассылаемых NREF инструкциями
          по рассылке при загрузке модуля.

A(A2) Управляет кодировкой строковых констант.
      А0 - резервная кодировка,
      А1 - кодировка АЦПУ-128,
      А2 - кодировка ISO-Дубна,
      А3 - кодировка TEXT-Дубна
           (используется восьмибитовое представление),
      см. "Перекодировка" в разд. 2.6.

      Для последующего объяснения управляющих режимов значение N
      вычисляется следующим образом: N:=ORD(C) - ORD('0'),
      где С - вторая литера в управляющем режиме, а N - число
      после буквы в псевдокомментарии.

D(D0) Режим условной компиляции, отладочного вывода и трассировки
      входов/выходов в процедуры/функции.

      Будем рассматривать цифру после D в двоичном виде К3,К2,К1,
      т.е. при D5 K3=1, K2=0, K1=1.

      Если К1=1, то при вызове процедуры/функции в некоторой строке
      выполняется следующий оператор:
        WRITE('<Идентификатор профедуры/функции>
               EXIT.')
      Если K2=1, то все вызовы стандартной процедуры DEBUG
      эквивалентны WRITELN, иначе они эквивалентны пустому оператору.
      Внимание! При K2=0 в параметрах для оператора DEBUG не должно
      быть символа ")".

      При К3=0 текст программы, заключенной в управляющие комментарии
        (*=Z-*)
        Текст программы
        (*=Z+*)
      игнорируется, при K3=1 управляющий режим Z не оказывает
      никакого влияния.

K(K4) N*1024 - размер памяти для размещения глобальных переменных.
      Память выделяется, если в программе были обращения к
      стандартной процедуре NEW - размещения глобальных переменных.

B(B1) N*256 - для буфера последовательных паскаль-файлов в стеке для
      переменных с последующими определениями типов файлов будет
      выделено не менее 256*N ячеек памяти.

L(L1) Управление печалью информации об исходной программе.
      0 - никакой печати; в случае ошибок, однако, выдаются тексты
          сообщений об ошибках, текст исходной строки, содержащей
          ошибки, и указатели на места обнаружения ошибок.
      1 - печатается восьмеричный относительный адрес загрузки,
          десятичный порядковый номер строки исходного текста
          и собственно строка.
      2 - кроме информации, печатаемой по L1, печатаются заготовки
          сгенерированных кодов.
      3 - кроме информации, печатаемой по L1, печатается
          распределение памяти для переменных и полей в записях.

S(S0) При N IN [0..2] служит для управления изображением внешних
      идентификаторов; на следующей таблице приведено возможное
      использование данного управляющего режима для идентификатора Т.

      +----+-----------------+--------------------------+
      | NS |Изображение общей|Изображение идентификатора|
      |    |  переменной Т   |   внешней процедуры Т    |
      +----+-----------------+--------------------------+
      |  0 |      *T*        |            T             |
      |  1 |       T*        |            T*            |
      |  2 |       T         |            T             |
      +----+-----------------+--------------------------+

      Строка исходного текста, содержащая псевдокомментарий (*=S3*),
      будет распечатана с порядковым номером 1.

      В режиме S4 позиции с 73 по 80 будут распечатываться перед
      первой позицией.

      Специальные режимы S5 и S6 можно использовать только в
      некоторых системных применениях. {S5 - отключение работы с
      внешними файлами; S6 - упаковка полей справа налево}

      Режим S7 включает проверку корректности указателей,
      см. режим T+.

      {Режим S8 - выключение проверки переполнения стека.}

Z(Z+) См. описание управляющего режима D.

F(F-) Данный режим управляет интерфейсом между Паскаль и Фортран
      модулями.

   а) "F+" перед описанием внешней Фортран процедуры/функции
      блокирует проверку числа, типа и видапараметров при обращении
      к определяемой Фортран процедуре/функции. При этом все
      параметры передаются по ссылке, как это принято в Фортране.

      Внимание -1 !!! Передача выражений в данном режиме приводит
      к ошибке.

      Внимание -2 !!! Транслятор автоматически устанавливает режим
      "F-" после каждого заголовка определения ФОРТРАН
      процедуры/функции.

   б) Паскаль-Паскаль-Фортран интерфейс.
      Системная общая переменная P/STACK указывает на область
      сохранения необходимой информации для интерфейса между
      двумя Паскаль программами и Паскаль и Фортран
      процедурами/функциями.

      При выполнении Паскаль программы устанавливается Паскаль-режим.

      Если вызов Фортран-модуля транслирован в режиме "F+", то перед
      передачей управления соответствующему Фортран-модулю
      устанавливается Фортран режим. Для вызова Паскаль программы
      из Паскаль программы необходимо объявить её, как Фортран
      подпрограмму.

      Возможен вызов Паскаль-процедур из Фортрана, в этом случае,
      если Паскаль процедура использует файлы, необходимо !!!
      в начале процедуры выполнить
        BESM(100000B); BESM(67140001B);
      и в конце
        BESM(100017B); BESM(67140001B);

      Примеры.

      1) (*=F+*)
         PROCEDURE LOADGO (I:INTEGER); FORTRAN;
         (*=F+*)
         . . . . . . .
                   LOADGO (X, Z, 'TWOPAR')
                   LOADGO (X, 1, 'TREEE')
                   LOADGO ('TIME')
                   . . . . . . .

      2) PROGRAM TEST (OUTPUT, TT);
         (*=F+*)
         PROCEDURE TEST; FORTRAN;
         BEGIN WRITELN(TT); TT:=T-1;
         (*=F+*) IF TT>0 THEN TEST;
                 WRITELN('***', TT);
         END. DATA TT:=7 END.

         /* !!!
          * Следует ли "TT:=T-1;" читать как
          * "TT:=TT-1;" ?..
          */

1.3. Заголовок программы.

В заголовке программы перечисляются все внешние информационные
переменные для данной программы. Синтексис:

PROGRAM <Имя-программы>
        (<Параметр-программы> [, <Параметр-программы>]...);

Параметры программы разделяются на две основные группы:
идентификаторы внешних файлов с возможными дополнениями и
идентификаторы общих переменных (именование COMMON области
языка Фортран).

<Параметр программы> ::= <Параметр-файла>
        <Идентификатор-общей-переменной>

/* !!!
 * Пропущено "|" ?
 */

<> ::= <Идентификатор-файла>[<Указатель-файла-для-чтения>]
        [<Дополнение для файла типа Фортран>|
         <Дополнение для файла типа Паскаль>]

<Указатель-файла-для-чтения> ::= *

<Дополнение для файла типа Фортран> ::= 50|51

<Дополнение для файла типа Паскаль> ::=
        <Восьмеричное-целое-от-1000000B-до-1743671743B>

Восьмеричное целое в последнем случае рассматривается как ННННТТЗЗЗЗ,
где НННН - число зон, ТТ - математические номера направления и
устройства, ЗЗЗЗ - начальная зона последовательного файла.

Номера 50 и 51 для дополнения для файла типа Фортран представляют
собой логические номера, принятые в мониторной системе "Дубна" для
обозначения файла ввода с П/К с помощью подпрограммы READ и печати
строки текста с помощью подпрограммы PRINT8. Следует отметить, что
в подпрограмме PRINT8 первая позиция в строке является управляющей
(см. описание печати в Фортране).

В списке параметров программы необходимо указывать внешний файл
OUTPUT, который по умолчанию связывается с логическим параметром
51 (см. "Выполнение Паскаль-программ").

Файл INPUT по умолчанию связывается с логическим номером 50, его
указание необязательно.

Вышеуказанные файлы INPUT и OUTPUT считаются уже объявленными
в программе переменными типа TEXT, т.е.

PACKED FILE OF CHAR

Все остальные параметры должны быть явно объявлены переменными в
блоке программы. Все параметры "имеют" внешние имена в соответствии
с управляющим режимом S (см. "Псевдокомментарии").

Приведём пример описания общих переменных на Фортране и Паскале:
    Фортран:
        COMMON /MM/ A, B(4), I(10)
    Паскаль:
            PROGRAM TEST (OUTPUT, MM);
                .....
            MM: RECORD
                A: REAL
                B: ARRAY [1..4] OF REAL;
                I: ARRAY [1..10] OF INTEGER
        END
            ......

В данном случае переменная MM для Фортрана и Паскаля одна (см.
управляющий режим S0, S1, S2).

1.4. Дополнительные возможности при описании констант.

В строковых (символьных) константах можно вместо литеры использовать
её восьмеричный эквивалент, которому предшествует знак "_"
(подчёркивание) или (тождество).

/* !!!
 * Символ тождества - три горизонтальных черты.
 */

Следующие выражения, например, истинны: (режим А2)

'_060' = CHR(60B)
'0'='_060'

Для того, чтобы записать символы конца текстового файла для системы
Пульт /БРЯ 72/ в кодировке АЦПУ-128 в файл Ф, можно использовать или

    WRITE(Ф, CHR(172B), CHR(175B))
или WRITE(Ф, '_172_175')
    WRITE(Ф, (*=A2*)'ЗЩ')

Кроме десятичных целочисленных констант, возможно использование трёх
типов восьмеричных констант: после восьмеричных цифр могут следовать
литеры B, C, T.

Литера B указывает на обычное восьмеричное целое, представленное
также, как десятичное, т.е. ненормализованное число с порядком.

В случае С(Т) не добавляется порядок числа и число располагается
справа (слева) слова.

Привидём примеры и их эквиваленты на языке Мадлен:

 50=,INT,50=,LOG,6400000000000062
50B=,LOG,6400000000000050
50C=,LOG,50
50T=,OCT,50

Обратим внимание, что максимальное целое число для ЭВМ БЭСМ-6 равно
17777777777777B.

1.5. Стандартные имена.

Идентификаторы стандартных констант, типов, переменных, процедур
и функций считаются объявленными в блоке, охватывающем программу,
поэтому их использование в программе не приводит к ошибке.
Исключением является стандартный идентификатор NIL, который является
зарезервированным словом.

А. Константы.

NIL - константа, ссылающаяся на адрес 74000B, тип которой считается
эквивалентным любому типу указателя.

FALSE, TRUE - константы логического типа.

Б. Типы.

BOOLEAN = (FALSE, TRUE)

INTEGER - максимальное значение элемента целого типа равно
        17777777777777B.
REAL - для действительных значений.
CHAR - дискретно-упорядоченный тип для представления литерных
        значений; минимальный элемент равен '_000';
        максимальный - '_377'.
ALFA = PACHED ARRAY [1..6] OF CHAR;
TEXT = PACKED FILE OF CHAR;
объявленный в режиме B1 (см. "Псевдокомментарии")

В. Переменные.

INPUT, OUTPUT: TEXT; (см. "Заголовок программы")

Переменная OUTPUT определена для любой программы, и её указание
в списке параметров программы обязательно.

Переменная INPUT определяется только при её указании в списке
параметров программы.

Г. Процедуры.

/* !!!
 * Буферная переменная вместо F(стрелка вверх)
 * обозначается в текста как F@
 */

Г1. Процедуры для работы с файлами.

PUT(F)           Добавляет значение буферной переменной F@ к файлу F,
           после PUT(F) значение F@ неопределено. PUT(F) определено
           только в случае, когда перед исполнением значение
           предиката EOF(F) есть TRUE, в противном случае печатается
           PUT(F) EOF(F)=FALSE и управление передаётся стандартной
           процедуре HALT. Во время работы оператора PUT(F) могут
           возникнуть следующие ошибки:
             NO EXTRA FILE TRACKS
           когда для размещения значений буферной переменной F@,
           где F - внешний файл, не хватает зон диска (ленты,
           барабана);
             NO LOCFILE TRACKS
           При нехватке трактов для локальных файлов (см. "Выполнение
           Паскаль-программ").

GET(F)           Смещает текущую позицию файла (головку чтения) на следующую
           компоненту и присваивает значение этой компоненты буферной
           переменной F@. Если следующей компоненты не чуществует, то
           F@ не определено или для файлов типа TEXT равно ' ', а
           предикат EOF(F) начинает вырабатывать значение TRUE.
           GET(F) определено только при значение EOF(F), равном FALSE,
           в противном случае при использовании GET(F) печатается
           сообщение
           GET(F) EOF(F)=FALSE
           и управление передаётся стандартной процедуре HALT.

RESET(F)   Возвращает текущую позицию файла F в начало файла
           и присваивает буферной переменной F@ значение первого
           элемента файла. Значение EOF(F) становится FALSE при
           непустом F, в противном случае F@ не определено, а
           значение предиката EOF(F) равно TRUE. Для внешнего файла
           типа Фортран с логическим номером 50 (чтение с П/К)
           процедура RESET(F) возвращает текущую позицию файла
           в начало текущей строки. Для файла с логическим значением
           51 употребление RESET(F) запрещено.

REWRITE(F) Уничтожает текущее значение F. Предикат EOF(F) становится
           равным TRUE. Запрещается употребление для внешнего файла
           с логическим номером 50.

WRITE, WRITELN, DEBUG - см. "Процедуры записи в файл",
READ, READLN - см. "Процедуры чтения из файла".

Г2. Процедуры для работы с упакованными массивами.

Пусть определены следующие переменные:
        A: ARRAY [M..N] OF T;
        Z: PACKED ARRAY [U..V] OF T;
где N-M >= V-U.

Тогда обращение к стандартной процедуре PACK(A,I,Z) означает

        FOR J:=U TO V DO Z[J]:=A[J-U+I],

а UNPACK(Z,A,I) означает

        FOR J:=U TO V DO A[J-U+I]:=Z[J].

Здесь J обозначает вспомогательную переменную, не встречающуюся
в других частях программы.

Внимание! Во время работы рассматриваемых процедур не проверяется
значение индексного выражения A[J-U+I] на принадлежность
соответствующему индексному типу.

Если тип переменной Z равен ALFA, то
PCK(A[T],Z) эквивалентно PACK(A,T,Z), и
UPPCK(A[T],Z) эквивалентно UNPACK(Z,A,T).

Г3. Процедуры динамического размещения.

NEW(P), DISPOSE(P),
NEW(P, T1, ..., TK), DISPOSE(P, ..., TK),
NEW(P=<Выр. цел. типа>), DISPOSE(P=<Выр. цел. типа>)

См. "Определение и реализация стандартных процедур размещения
глобальных переменных".

Г4. Процедуры для связи с системой МАРС

Система хранения данных МАРС /ФИЛ   / реализована В. И. Филипповым
(ВЦ АН СССР). При обращении к данным процедурам предполагается, что
в 30 (восьм.) зоне направления 40 (восьм.) находится система МАРС,
а на 63 (восьм.) зоне - область "КОБЛА", содержащая общий каталог
областей базы данных.

Для работы с системой МАРС в языке Паскаль-Монитор разработаны
следующие стандартные процедуры:

  NEWD, OPEND, GETD, MODD, DELD,

позволяющие отводить на некоторой памяти (барабаны, диски, ленты)
область МАРСа (NEWD), открывать область (OPEND), после открытия
засылать значения паскаль-переменных в область (PUTD), выбирать их
из неё (GETD), исключать элементы из области (DELD) и модифицировать
их значения (MODD).

Отметим, что к началу 1978 года аналогичные средства для работы
с областями МАРСа были реализованы в языках Лисп, Макро-БЕМШ,
Алгол-БЭСМ, Фортран, Алгол-ГДР и системе коллективного пользования
Пульт. Поэтому аппарат областей МАРСа позволяет эффективно
обмениваться информацией с различными системами программирования.

В языке Паскаль-Монитор, кроме рассматриваемых стандартных процедур,
сущесвуют средства для использования полных возможностей,
предоставляемых системой МАРС, которые описываются ниже.

Г4.1. Заведение базы данных.

Имеется два способа заведения базы данных:

а) С помощью приказа в системе Пульт, например:
        BD NEW <Имя-массива-системы-пульт>

б) С помощью стандартной процедуры NEWD, для которой надо указать
два параметра: имя новой дазы данных, информационное слово обмена
для начальной зоны и длину в зонах во втором параметре. Например,
выполнение оператора
        NEWD('ВРЕМЕН', 72330005B)
заведёт базу данных под именем 'ВРЕМЕН' на направлении 33 (восьм.)
с начальной зоны 5 длиной 72 (восьм.) зоны.

Г4.2. Открытие базы данных.

Оператор OPEND(<Выражение>) откроет базу данных, идентифицируемую
значением выражения простого типа.

Г4.3. Занесение, модификация и выборка

Занесение, модификация и выборка информации осуществляется
процедурами PUTD, MODD и GETD.

Синтаксис:

(PUTD|MODD|GETD)
  (<Информация-для-обмена>[,<Информация-для-обмена>]...)

<Информация-для-обмена> ::=
  <Имя-элемента-в-базе-данных><Переменная>[:<Указатель-длины>]

<Имя-элемента-в-базе-данных> ::= <Выражение-простого-типа>
<Указатель-длины> ::= <Выражение-целого-типа>

Переменная не должна быть файлом.

При занесении информации имени элемента не должно быть в открытой
области, при выборке информации имя элемента должно быть в
открытой области.

Стандартная процедура MODD модифицирует информацию, если она есть,
иначе записывает, то есть работает как PUTD.

При отсутствии указателя длины размер передаваемой информации
в словах определяется компилятором по соответствующему типу
переменной. При выборке информации размер памяти, отведённой
для переменной, должен быть не меньше размера выбираемого элемента.

Г4.4. Исключение элемента.

Исключение элемента из области осуществляется стандартной процедурой
DELD.

Синтаксис:

DELD (<Имя-элемента-в-базе-данных>[,<Имя-элемента-в-базе-данных>]...)

Г4.5. Настройка системы МАРС в Паскале.

При обращении к данным процедурам предполагается, что в 30 (восьм.)
зоне направления 40 (восьм.) находятся коды системы МАРС, а
на 63 (восьм.) зоне - область "КОБЛА" (каталог областей), содержащая
каталог областей, с которыми можно работать.

При использовании в языке Паскаль системы МАРС необходима зона кодов
системы МАРС КСМ, которая переписывается отдельно от личной системной
библиотеки - компилятора.

При отсутствии зоны КОБЛА её можно завести, используя Фортран
процедуру PASACD. Например, если необходимо завести каталог на
направлении 52(8) с 0 зоны длиной в одну зону, выполняем следующую
программу.

PROGRAM SETCOBLA (OUTPUT);
(*=F+*)
PROCEDURE PASACD (VAR I: INTEGER); FORTRAN;
BEGIN
        PASACD (1520000B)
END.

Если КОБЛА заведена не командой 1400063B, то её необходимо настроить
перед открытием областей.

Информация о расположении КОБЛы в виде MMMMZZNNNNB находится в ячейке
системного листа, распределяемого командой

P/BDSYS:,PC,1024

Для настройки КОБЛы используем внешнюю процедуру
PASSETAR "SET UP AREA". Например, чтобы настроить заведённую
в предыдущем разделе КОБЛу, можно выполнить:

PROGRAM T(OUTPUT);
PROCEDURE PASSETAR(I: INTEGER); EXTERNAL;
BEGIN
        PASSETAR(1520000B)
END.

Для выполнения произвольной МАРС команды

а) необходимые описания
   PROCEDURE PASBDI; EXTERNAL;
   PROCEDURE PASBD; EXTERNAL;

   Общая переменная-указатель BDV после выполнения процедуры PASBDI
   будет указывать на вектор МАРСа BDVECT (мс. ниже);

б) Для исполнения МАРС команды необходимо:
 - Выполнить хотя бы раз PASBDI,
 - используя переменную BDV, заслать параметры,
 - выполнить PASBD.

Некоторые полезные общие переменные:

P/BDSYS : ,PC, 1024  - лист для кодов системы МАРС;
P/BDBUF : ,PC, 1024
P/BDTAB : ,PC, 1024  - листы для буферов системы МАРС;

*ERSTOP* : ,LC, 1    - при ошибке, если *ERSTOP*=,LOG,0;
        (по умолчанию) будет продолжено вычисление, предварительно
        обратившись по умолчанию к пустой программе PASBDE;

*BDVECT* : ,LC, 250B - память для вектора;
        после выполнения PASBDI переменная *BDV* начинает указывать
        на *BDVECT*, и в *BDVECT* занесена информация о буферных
        листах, о реакции на ошибку и др.;

*BDV*: ,LC, 1        - указывает на текущий вектор МАРСа;
        см. также *BDVECT*;

*BDC* : ,LC, 7       - вектор констант; в нулевой ячейке
        информационное слово для считывания на нулевой лист
        системного листа МАРСа;

*BDERRN* : ,LC, 1    - записывает без порядка целое число -
        номер ошибки.

Г5. остальные стандартные процедуры.

EXIT|EXIT <Структурная-метка>|EXIT (<Структурная-метка>)

EXIT без параметров эквивалентна оператору перехода на метку перед
последним END текущей процедуры/функции.

EXIT с параметром (о структурной метке см. "Дополнительные
управляющие операторы") эквивалентен оператору перехода за оператор,
соответствующий указанной структурной метке.

Например,

(M) BEGIN
        B:=TRUE;
        FOR I TO 2*N DO
                IF M[I]='C' THEN BEGIN
                        B:=FALSE;
                        EXIT M
                END
END;

HALT. Если какой-нибудт из блоков загруженных Паскаль-программ
был оттранслирован в режиме "P+" (см. "Псевдокомментарии"), то
вызывается внешняя процедура PASSPMD, печатающая авостную распечатку.
Далее выполняется оператор перехода на последний END программы.

MAPIA(I,A). Если I - выражение типа INTEGER, например, равное 345B,
и A - переменная типа ALFA, то после исполнения данной процедуры
переменной A будет присвоено значение '000345' в кодировке
ISO_ДУБНА.

MAPAI(A,I). Выполняет действие, обратное процедуре MAPIA.

STOP - Эквивалентна выполнению экстрактора конца задачи 74 (восьм.);
можно использовать, например, при нежелании пользователя закрыть
внешние файлы.

BESM(I) - предназначена для системного использования. Целое выражение
I трактуется как машинная команда ЭВМ БЭСМ-6, вставляемая в данное
место объектного модуля.

Обратим внимание, что кроме стандартных процедур в библиотеке
компилятора Паскаль-Монитор имеются полезные внешние процедуры
(см. "Утилиты для системы Паскаль-Монитор").

Д. Функци.

Д1. Арифметические функции.

SIN(X), COS(X), EXP(X), LN(X), SQRT(X), ARCTAN(X), ARCSIN(X).
Тип выражения Х должен быть целым или вещественным, результат имеет
вещественный тип.

ABS(X)   Вычисляет абсолютную величину значения выражения Х. Тип Х
         должен быть целым или вещественным, тип результата
         совпадает с типом Х.

SQR(X)   Вычисляет квадрат значения выражения Х. Тип Х
         должен быть целым или вещественным, тип результата
         совпадает с типом Х.

SUCC(X)  Выбирает следующее по порядку значение
         дискретно-упорядоченного типа.

PRED(X)  Выбирает предыдущее по порядку значение
         дискретно-упорядоченного типа.

Д2. Предикаты.

ODD(X)   Тип Х должен быть целым; результатом является значение
         выражения X MOD 2 = 1.

EOF(F)   Указывает, находится ли файл F в состоянии "конец файла".

EOLN(F)  Указывает, находится ли файл F в состоянии "конец строки".

Д3. Функции преобразования типов.

ROUND(X) Округляет значение вещественного типа в значение целого
         типа.

TRUNC(X) Отбрасывает у вещественного типа выражения дробную часть и
         преобразует его в целый тип.

ORD(X)   Преобразует дискретно-упорядоченный тип, а также тип
         указателя в целый тип.

CHR(X)   Выражение Х должно быть целого типа; результат - значение
         символьного типа CHAR, порядковый номер которого есть Х.

PTR(X)   Преобразует значение целого типа в значение типа указатель.

REF(X)   Взятие ссылки на переменную Х; результат имеет тип,
         эквивалентный типу указателя константы NIL, т.е. совместимый
         со всеми типами указателей (то же самое справедливо и для
         функции PTR).

Д4. Дополнительные функции.

CARD(X)  Вычисляет кардинальное число множества; Х должно быть типа
         множества, результат - целого типа.

MINEL(X) Х должно быть типа множества. Определяется порядковый номер
         минимального элемента множества Х; если множество Х пустое,
         то результат равен минус единице.

1.6. Процедуры записи в файл.

Стандартная процедура WRITE служит для записи информации в
последовательный файл. При этом типы элемента файла и записываемого
значения должны быть эквивалентны, за исключением записи значений
в символьные файлы. В последнем случае перед записью происходит
преобразование значений в символьные строки.

Пусть Ф - переменная типа файл из последовательных элементов
          произвольного типа.
      F - символьный файл.
      Р1,...,РK - так называемые параметры для записи;
      Е - выражение;
      ДП, ДМ - выражения целого типа.

Тогда:

- WRITE(Ф,P1,...,PK); эквивалентно
  WRITE(Ф,P1); ...; WRITE(Ф,PK);

- WRITE(P1,...,PK); эквивалентно
  WRITE(OUTPUT, P1, ..., PK);

- WRITELN(F, P1, ..., PK); эквивалентно
  WRITE(F, P1, ..., PK); WRITELN(F);

- Параметр для записи имеет форму E и в случае записи в файл F
  формы E|E:ДП|E:ДП:ДМ|E:ДП ОСТ|E ОСТ;

/* !!!
 * @ заменяет символ "стрелка вверх"
 */

- WRITE(Ф, E) эквивалентно в случае эквивалентности типов выражения
  E и элемента файла Ф операторам
    Ф@:=E; PUT(Ф)
  При записи в символьный файл выражение E может быть типа: INTEGER,
  REAL, CHAR, определяемого идентификаторами (например,
  BOOLEAN=(FALSE,TRUE) ), символьных строк (т.е. упакованными и
  неупакованными символьными массивами), а также произвольного типа,
  значение которого размещается в 48 битах или одном слове.

  В последнем случае и в случае дополнения ОСТ производится
  восьмеричный вывод, причем, если длина поля меньше 16, то
  откидываются и нулевые, и ненулевые цифры.

  Если длина строкового изображения значения выражения Е меньше ДП,
  то слева от полученного строкового изображения приписывается
  соответствующее число пробелов. Если параметр ДП опущен, то
  используется следующее соглашение по умолчанию.

  ----+------+------+-----------+---------+------+--------
  Тип | CHAR | ALFA | Идентифи- | INTEGER | REAL | Восьме-
      |      |      | каторный  |         |      | ричный
  ----+------+------+-----------+---------+------+--------
  ДП= |  1   |  6   |     8     |   10    |  14  |   17
  ----+------+------+-----------+---------+------+--------

  Для строк по умолчанию ДП равно длине строки.

  Если ДП меньше, чем требуется, то преобразованное значение
  записывается без пробелов спереди (за исключением восьмеричного
  вывода - см. выше).

  Параметр ДМ - длина мантиссы - указывается только при выводе
  вещественных значений. Значение ДМ управляет длиной мантиссы,
  а также видом вывода (экспоненциальная форма или с фиксированной
  точкой).

  Пусть FIX - внутренняя переменная компилятора, управляющая видом
  вывода а ДМ - значение второго параметра. Тогда при выводе неявно
  выполняются следующие операторы:

  FIX := FALSE; (* Т.е. форма вывода экспоненциальная *)
  (T) SELECT
          ДМ > 20: _(
                ДМ := ДМ - 20;
                FIX := TRUE;
                GOTO T
        _);
        ДМ > 10:
                ДМ := 10;
        ДМ > 1:
                ДМ := 1
  END;

1.7. Процедуры чтения из файла.

Стандартная процедура READ используется для чтения значений
из последовательных файлов. При этом типы элемента файла и переменной
для чтения должны быть эквивалентны, за исключением чтения из
символьных файлов. В последнем случае происходит необходимое
преобразование.

Пусть Ф - переменная типа файл из элементов произвольного типа;
      F - символьный файл;
      П1, ..., ПК - переменные, которым при чтении будут присвоены
                значения.

Тогда:
-    READ (Ф, П1, ..., ПК) эквивалентно
     READ (Ф, П1); ..., READ (Ф, ПК)

-    READ (П1, ..., ПК) эквивалентно
     READ (INPUT, П1, ..., ПК)

-    READLN (F, ..., ПК) эквивалентно
     READ (F, П1, ..., ПК); READLN (F);

Процедура READLN определяется:

PROCEDURE READLN(VAR F: TEXT);
BEGIN
        WHILE NOT EOLN(F) DO GET(F);
        GET(F);
END

READ(Ф,П) эквивалентно в случае эквивалентности типов переменной П
и элемента файла Ф операторам
        П := Ф@; GET(Ф)
При чтении из символьного файла тип переменной П может быть
строковым, CRAR, INTEGER, REAL.

Чтение в переменную целого типа определяется:

PROCEDURE READI(VAR F: TEXT; VAR J: INTEGER);
VAR MINUS: BOOLEAN;
BEGIN
        WHILE (F@ = ' ') OR EOLN(F) GO GET(F);
        MINUS := F@ = '-';
        J := 0;
        IF F@ IN ['+', '-'] THEN GET(F);
        WHILE (F@ >= '0') AND (F@ <= '9') DO BEGIN
                J := 10*J + ORD(F@) - ORD('0');
                GET(F);
        END;
        IF MINUS THEN J := -J;
END;

Чтение в переменную П вещественного типа определяется:

PROCEDURE READR(VAR F: TEXT; VAR R: REAL);
VAR
        J: INTEGER;
        MINUS: BOOLEAN;
/*
 * !!! начало блока без перевода строк
 */
FUNCTION INTLEN: INTEGER; EXTERNAL;
(* ПРИ ИСПОЛЬЗОВАНИИ СРАЗУ ПОСЛЕ READ(F,J) ОПРЕДЕЛЯЕТ ДЛИНУ ПОСЛЕДОВАТЕЛЬНОСТИ ЦИФР, ПРЕОБРАЗОВАННЫХ В J *)

FUNCTION INTSIGN: BOOLEAN; EXTERNAL;
(* ПРИ ИСПОЛЬЗОВАНИИ СРАЗУ ПОСЛЕ READ(F,J) ВЫРАБАТЫВАЕТСЯ ЗНАЧЕНИЕ TRUE,
ЕСЛИ ПЕРЕМЕННАЯ J ЧИТАЛАСЬ СО ЗНАКОМ "-", В ПРОТИВНОМ СЛУЧАЕ FALSE. *)

FUNCTION POWER (X: INTEGER; Y: INTEGER): REAL;
(* ВОЗВОДИТ X В СТЕПЕНЬ Y *) EXTERNAL;
BEGIN
        READ(F,J);
        MINUS = INTSIGN;
        IF MINUS THEN R := -J ELSE R := J;
        IF F@ = '.' THEN BEGIN
                GET(F);
                READ(F,J);
                IF J < 0 THEN
                        R := R / POWER(10, -J)
                ELSE
                        R := R * POWER(10, J)
        END;
        IF MINUS THEN R := -R;
END;

1.8. Определение и реализация стандартных процедур размещения динамических переменных.

В системе не используются никакие автоматические системы сборки мусора. Использование повлекло бы значительные издержки времени и памяти (особенно при упакованных указателях) при работе с указателями и процедурами.

Динамические переменные (т.е. не связанные со входом и выходом из процедур) размещаются в области памяти, которую будем называть пулом данных.

Опишем структуру пула:

TYPE WORDS = RECORD
        NEXT: @WORDS;
        HOW: INTEGER
END;
VAR POOL: RECORD
        FREE, FML1: @INTEGER;
        FMLK: @WORDS;
        DELIM: @INTEGER;
        POOLS: ARRAY 1 .. POOLSIZE OF INTEGER
END;

Верхнее значение задаётся в псевдокомментарии, управляющем режимом К (см. "Псевдокомментарии"). При умолчании выделяется POOLSIZE = 4096 слов, если,
конечно, в программе используется стандартная процедура размещения NEW.

Для программ, требующих пул данных, перед работой программы выполняется

WITH POOL DO BEGIN
        FREE := REF(POOLS);
        DELIM := REF(POOLS [POOLSIZE]);
        FML1 := NIL;
        FMLK := NIL
END;

При затребовании стандартной процедурой NEW(P) некоторой памяти, например,
К ячеек, выполняются следующие действия:

WITH POOL DO BEGIN
        P := FREE;
        FREE := PTR(ORD(FREE) + K;
        IF ORD(FREE) >= ORD(DELIM) THEN FROMLIST(P)
END;

Где процедура FROMLIST пробует выделить память из списков ненужной памяти
FML1 и FMLK. В Случае неуспеха, если 45 IN RGEXPORT, переменной P присваивается значение NIL, иначе печатается NO GLOBAL MEMORY и управление передаётся стандартной процедуре HALT.

Отметим, что в компиляторе Паскаль-монитор реализовано три варианта стандартной процедуры NEW, а именно:
NEW(P)
NEW(P,T1,...,TK)
NEW(P=<Выражение-целого-типа>)

В последнем случае значение выражегтя задаёт размер выделяемой памяти в словах. Этот вариант удобно использовать для компактного представления различных данных. Рассмотрим, например, выделение памяти для прямоугольной матрицы M*K, размерность которой определяется в программе. Для этого определим следующие типы:

TYPE
        POW = ARRAY(1..1000) OF REAL;
        PROW = @ POW;
        MATP = ARRAY 1..1000 OF PROW;
        PR = @ MATP;

и переменные X, Y типа указатель на MATP. Вызовы процедур РАМ(Х, 5, 20)
и РАМ(Y, 30, 40) выделяет память для прямоугольных матриц 5*120 и 30*40. Переменная P@[4]@[95] выбирает (4,95) элемент первой матрицы. Процедуру РАМ можно определить следующим образом:

PROCEDURE PAM (VAR P: PR; M, N: INTEGER);
VAR
        J: INTEGER;
        P2: PROW;
BEGIN
        NEW(P=M);
        FOR J TO M DO
                NEW(P[J] = N)
END;

Стандартная процедура SETUP(P) эквивалентна оператору
P := POOL.FREE;
Процедура ROLLUP(P) эквивалентна POOL.FREEE := P.
Стандартная процедура DISPOSE(P) собирает "ненужную" память в два списка:
  POOL.FML1 - список одиночных слов, и
  POOL.FMLK - здесь во втором слове содержится длина списка "ненужной" памяти в словах. Стандартная процедура DISPOSE используется в трёх модификациях, также как и стандартная процедура NEW.

1.9. Дополнительные управляющие операторы.

В целях совместимости с системами Паскаль-Автокод для ЭВМ БЭСМ-6 и системы Паскаль для Си-Ди-Си 3300/ЩУС 74/, а также в соответствии с идеями структуризации программ, введены следующие управляющие операторы.

                Операторы перебора.

Вместо последовательности вложенных условных операторов, например

IF A THEN B ELSE
IF A1 THEN B1 ELSE
IF A2 THEN B2 ELSE
IF A3 THEN B3

Можно использовать оператор:

SELECT
A  : B;
A1 : B1;
A2 : B2;
A3 : B3
END;

Синтаксис:

<Оператор-перебора> ::= SELECT
        <Условный-вариант> [; <Условный-вариант>] ... END
<Условный-вариант> ::= <Выражение> : <Оператор>
<Выражение> должно иметь логический тип.

                Структурные метки.

Каждый оператор может бытьт помечен структурной меткой.
<Оператор> ::= (<Структурная-метка>) <Оператор> | <Оператор-стандартного-языка-Паскаль>
<Структурная-метка> ::= <Идентификатор>

Областью действия структурной метки является следующий за ней оператор.

В области действия структурной метки, например (М), могут быть операторы, передающие управление на начало оператора, помеченного структурной меткой: GOTO M, и операторы, передающие управление за данный оператор: EXIT M.

Структурные метки осуществляют право каждого оператора на итерацию и завершение.

1.10. Раздельная компиляция программ.

В этом разделе описываются конструкции языка Паскаль-Монитор, позволяющие раздельно компилировать программы.

В Паскаль-программе возможно использование внешних процедур/функций и внешних Фортран подпрограмм/функций.

<Описание-внешней-процедуры-функции> ::= <Заголовок-процедуры-функции> ; EXTERNAL;
<Описание-внешней-Фортран-подпрограммы-функции> ::= <Заголовок-процедуры-функции> ; FORTRAN;

Вызов внешней процедуры/функции ничем не отличается от стандартного вызова, однако для правильного использования необходимо соответствие статических уровней описания, числа параметров, их типа и внешних используемых переменных. (Вообще говоря, необходимо совпадение областей переменных в обеих программах, или в вызываемой программе соответствующая область должна быть пустой. Имеются в виду собственные переменные программы). Несоответствие указанных объектов ведёт к ошибкам во время выполнения программы.

При вызове внешней фортран подпрограммы/функции фактические параметры, соответствующие формальным со словами VAR, передаются по ссылке, иначе - по значению. Последний случай удобен при использовании внешних модулей языка Ассемблера Мадлен /ВОЛ 69/.

 Если в Паскаль-программе некоторые процедуры/функции будут использованы как внешние в другой программе, то их необходимо компилировать в режиме "Е+". (см. "Псевдокомментарии"). Примеры раздельной компиляции программ см. в разделе "Совместное исполнение модулей".

1.11. Присваивание констант рассылкой.

Возможно присваивание констант переменным, описанным в блоке программы, при загрузке модуля (эквивалентно оператору Фортрана DATA). Это достигается специальным разделом <Данные>, описанным сразу после программы.

<Данные> ::= DATA <Рассылка> [; <Рассылка>] ... END

<Рассылка> ::= <Переменная> := <Константа-с-повторением> [, <Константа-с-повторением>] ...

<Константа-с-повторением> ::= <Обозначающее-конатанту-выражение> [: <Повторитель>]

<Повторитель> ::= <Положительная-константа-целого-типа>

Идентификатор DATA должен следовать непосредственно после заключительной
точки программы. Раздел данных не будет обработан, если после точки следует пробел.

При определении переменной не должны быть использованы другие переменные или обращения к функциям, а также переменные не должны быть "упакованными".

Обозначающее константу выражение - это обычное выражение, состоящее из констант, знаков операций и обращения к стандартным (арифметическим) функциям. Недопустимы только знаки отношения.

При отсутствии повторителя его значение считается равным единице. Присваивание происходит в порядке вхождения констант. Строковые константы не должны быть более 6 символов.

Опишем процесс присваивания рассылкой.

Пусть КОН - функция, дающая значение повторителя константы, значение которой возвращается в параметре, при исчерпании списка констант функция КОН возвращает значение 0.

Переменная К - запись с совмещёнными полями различных типов констант, Р - указатель на такую запись, I и J - переменные целого типа.

P := REE(ПЕРЕМЕННАЯ);
J := KOH(W);
REPEAT
        FOR I TO J DO BEGIN
                P@ := W;
                P :=PTR(ORD(P) + 1)
        END;
        J := KOH(W)
UNTIL J = 0;

Пример раздела данных.

PROGRAM TEST (OUTPUT);
VAR M: ARRAY 1..1000 OF INTEGER;
...........
BEGIN
.........
END.DATA
M := 0: 50, ROUND(SQR(3.14)): 50;
M[5] := 5;
M[1000] := 0, 5, 7:2
END

/*
 * !!! конец блока без перевода строк
 */

1.12. Использование предопределений.

Обычно в языке Паскаль-Монитор все определяющие вхождения объектов должны
предшествовать использующим вхождениям, однако в разделе описания типов данных
разрешается в некоторых случаях использование идентификаторов типа, которые
далее будут определены в этом же разделе. Тип таких идентификаторов будем называть
предопределённым.

/* !!!
 * "@" = стрелочка вверх
 */

Если перед предопределённым идентификатором типа стоит символ "@"
(определение типа указателя на предопределённый тип), то предопределяется
идентификатор произвольного типа; при отсутствии символа "@" предопределяется
обязательно тип указателя.

По окончании раздела описания типов, если не доопределены все предопределённые типы,
печатается сообщение об ошибке с перечислением неопределённых идентификаторов типа.

Очевидно, что компилятор фиксирут ошибку и в случае, когда предопределённый
идентификатор типа указатель доопределяется другим типом.

Рассмотрим следующий пример:

PROCEDURE A;
BEGIN
... B(2) ...
END;

PROCEDURE B(T: INTEGER);
BEGIN
... A; ...
END;

Последовательность процедур подобного рода со взаимными ссылками в версии языка
Паскаль-Монитор должна быть переписана в виде:

PROCEDURE B(T: INTEGER); FORWARD;

PROCEDURE A;
BEGIN
... B(2) ...
END;

PROCEDURE B;
(* ПАРАМЕТРЫ МОЖНО УКАЗАТЬ В КОММЕНТАРИИ <T: INTEGER> *)
BEGIN
... A; ...
END;

1.13. Расширение оператора цикла.

Начальное значение в операторе цикла можно опускать. В этом случае оно считается
равным значению соответствующего дискретно-упорядоченного типа, где ORD(J)=1.

Например,
        FOR J TO 9 DO A(J);
эквивалентно
        FOR J := 1 TO 9 DO A(J);

Расширение операции MOD

Операция MOD над множествами означает разностное сложение множеств, т.е. пусть
A, B: SET OF T, тогда A MOD B означает (A-B)+(B-A).

Данная операция легко реализуется на БЭСМ-6 при командой "Сравнение по модулю два".

1.15. Определение типа массива.

Квадратные скобки при определении типа массива  можно опускать.

2. Эксплуатация системы Паскаль-Монитор.

2.1. Трансляция паскаль-программ в модуль загрузки.

Компилятор с языка Паскаль-Монитор на модуль загрузки мониторной системы "Дубна"
вызывается картой

*CALL *PASCAL

Модуль *PASCAL после некоторой предварительной работы вызывает основной блок
компилятора PASCOMPL, программа которого написана на языке Паскаль-Монитор.

Перед вызовом компилятора необходимо установить режим увеличенной памяти картой

*CALL FICMEMORY
а также настроиться на считывание системной библиотеки паскаля картой
*PERSO:37230 (в ВЦ АН СССР)
*PERSO:67640 (в ИТМ и ВТ АН СССР)

Примеры пакетов для трансляции.

а) Трансляция простой программы.

/* !!!
 * Символ ^ означает надчёркивание
 */

ШИФР 419900 3С2^
ЛИСТ 0-37^
ЛЕНТ 67(2048)^
Е
ЕЕВ1А3
*NAME T
PERSO:67640
*CALL FICMEMORY
*CALL *PASCAL
        PROGRAM TEST (OUTPUT);
        VAR I: INTEGER;
        BEGIN
                FOR I:=5 TO 8 DO WRITELN(I);
        END.
*END FILE

б) Использование личной библиотеки.

Необходимо оттранслировать паскаль-программу и дозаписать её в личную библиотеку,
расположенную на направлеении 66 (восьмеричном) с 50 (восьмеричной) зоны, всего
10 зон. Карты задания:

*NAME T
*PERSO:66050
*             СЧИТЫВАНИЕ ЛИЧНОЙ БИБЛИОТЕКИ ВО ВРЕМЕННУЮ
*PERSO:67640, CONT
*             ДОПИСЫВАНИЕ БИБЛИОТЕКИ ПАСКАЛЯ ВО ВРЕМЕННУЮ БИБЛИОТЕКУ
*CALL FICMEMORY
*CALL *PASCAL
        ТЕКСТ_ПАСКАЛЬ_ПРОГРАММЫ
*CALL PASHELP
У      .
*TO PERSO:66050
*END FILE

Карты, следующие после паскаль-программы, вызывают сервисную систему PASHELP, которая
в режие У (убрать) убирает из временного каталога все имена, начинающиеся с "PAS"
или "P/". См. "Работа сервисной программы PASHELP".

Вместо карты
*CALL PASSHELP
рекомендуется использовать разработанную в ИТМ и ВТ АН СССР подпрограму LIBSUB. С её
помощью можно из временной библиотеки задачи "вычесть" одну или несколько библиотек.

Пример использования:

* ВЫЧИТАНИЕ
*PERSO:67640
*     БИБЛИОТЕКА ПАСКАЛЯ
*PERSO:31225, CONT
*     ЛИЧНАЯ БИБЛИОТЕКА
*CALL *PASCAL
 PROGRAM A (OUTPUT);
 _( ... _)
*CALL *PASCAL
 PROGRAM B (OUTPUT);
 _( ... _)
*CALL LIBSUB
67640
*TO PERSO:31225
*      ЛИЧНАЯ БИБЛИОТЕКА ДОПОЛНИТСЯ МОДУЛЯМИ А И В
*END FILE

Внимание! После использования процедуры LIBSUB нормальный счёт по программе
невозможен!

2.2. Выполнение паскаль-программ.

Передача управления на счёт оттранслированным паскаль-программам происходит следующим
образом:
 - подготавливается информация для связи внешних файлов паскаль-программы, если это
   необходимо;
 - присваиваются значения общим переменным, если это необходимо;
 - вызывается модуль паскаль-программы картой:
   *CALL ИМЯ-МОДУЛЯ-ПАСКАЛЬ-ПРОГРАММЫ

Модуль загрузки паскаль-программы и внешних процедур полностью удовлетворяет
соглашению о связях, принятому в мониторной системе "Дубна": значения регистров
1, 2, 3, 4, 5, 6, 7, 15 сохраняются; возвращается стандартный режим выполнения
команд.

Следующие карты оттранслируют и выполнят паскаль-программу.

*NAME TTT
*PERSO:67640
*CALL FICMEMORY
*CALL *PASCAL
 PROGRAM T(OUTPUT);
 BEGIN WRITELN(77) END.
*EXECUTE
*END FILE

В последующем задании будет распечатан полный каталог имён временной библиотеки.

*NAME PRINT CATALOG
*PERSO:67640
*CALL FICMEMORY
*CALL *PASCAL
PROGRAM KTLPRINT (OUTPUT, KTL);
TYPE
        MH = SET OF 0..47;
        REC = RECORD
                NAME, WHERE: MH
        END;
VAR
        I: INTEGER;
        X: REC;
        KTL: FILE OF REC;
PROCEDURE PASTPR (X: MH); EXTERNAL;
BEGIN
        I := 0;
        READ(KTL, X);
        READ(KTL, X);
        WHILE (X.NAME <> []) OR (X.WHERE <> [0..47]) DO BEGIN
                WRITE(' ');
                PASTPR(X.NAME);
                I := I + 1;
                IF I MOD 10 = 0 THEN
                        WRITELN;
                READ(KTL, X);
        END;
        WRITELN
END.
*CALL PASHELP
R KTLPRINT *KTL* 2210000B
*EXECUTE
*END FILE

В вышеприведённой программе для настройки внешнего файла KTL снова был применён
сервисный модуль PASHELP, в данном случае сгенерировавший модуль загрузки под именем
PROGRAM, который настроит внешний файл KTL на 2 барабана 21(8), начиная с нулевого
тракта.

В библиотеке имеется программа LIBSUB, предназначенная для  вычитания библиотек.
Следующий пакет дозапишет одну программу в библиотеку.

*NAME ДОЗАПИСЬ
*PERSO:67640
*PERSO:<ВАША БИБЛИОТЕКА>, CONT
*CALL FICMEMORY
*CALL *PASCAL
 PROGRAM ПИ (OUTPUT);
 _(
         WRITELN('3 РУБ 14 КОП')
 _).
*CALL LIBSUB
67640
*TO PERSO:<ВАША БИБЛИОТЕКА>
*END FILE

После выполнения программы LIBSUB счёт невозможен (в том же запуске).

2.3. Работа сервисной программы PASHELP

Сервисная программа PASHELP предназначена для облегчения управления процессами
трансляции и выполнения паскаль-программ, а также для облегчения генерации
векторов констант в кодировке TEXT-ДУБНА для сервисных работ мониторной системы и
убирания из временной библиотеки системных паскаль-имён.

Модуль PASHELP представляет собой транслятор, обрабатывающий следующий сервисный
язык.

<Сервисный-язык> ::=
        (<Раздел-управления-компилятором>|
        <Раздел-запуска-паскаль-программ>|
        <Раздел-генерации-вектора-констант>|
        <Раздел-уборки-стандартных-имён>|
        <Раздел-настройки-буферных-листов-и-трактов>|
        <Раздел-связывания-файлов>)<Точка>

<Точка> ::= .

<Раздел-управления-компилятором> ::=
        P <Режим-печати> <Начальный-адрес-загрузки> <Адрес-вводного-файла>

<Режим-печати> ::= 0|1|2|3

0 - выключить всякую печать,
1 - печать только на видеотон,
2 - печать только на АЦПУ-128,
3 - печать на видеотон и на АЦПУ-128.
См. также раздел "Организация диалога".

<Начальный-адрес-загрузки> ::= <Целое>
<Целое> ::= <Десятичное-целое> | <Восьмеричное-целое>
<Десятичное-целое> ::= <Цифра-от-0-до-9>...
<Восьмеричное-целое> ::= <Цифра-от-0-до-7>...В

<Адрес-вводного-файла> ::= 50 | <Восьмеричное-целое-от-1000000В-до-1743671743В>

Здесь восьмеричное целое ЧЧЧЧННЗЗЗЗ расшифровывается:
ЧЧЧЧ - длина внешнего файла в зонах.
НН   - математические номера направления и устройства,
ЗЗЗЗ - номер начальной зоны внешнего файла.

Предложение раздела управления компилятором генерирует управляющий компилятором
модуль PASCONTR, в котором указывается режим вывода, начальный относительный адрес
загрузки кодов строк исходной программы при распечатке и адрес файла, содержащего
текст программы.

По умолчанию устанавливается режим
        Р 1 0 50
т.е. вывод только на видеотон (см. "Организация диалога"), начальный адрес загрузки
при распечатке равен нулю, и трансляция происходит с П/К, т.е. карта считывается
стандартной программой мониторной системы READ* .

<Раздел-запуска-паскаль-программ> ::=
        R <Идентификатор-программы> [+] [<Режим-печати>] [<Связывание-файла>] ...
<Связывание-файла> ::= <Идентификатор-внешнего файла> <Адрес-файла>
<Адрес-файла> ::= <Адрес-вводного-файла> | 51 | 0

Если адрес файла равен нулю, то связываемый внешний файл будет локальным, программа
связывает не более 3 внешних файлов.

Результатом работы сервисной программы PASHELP в режиме R является модуль загрузки
с именем PROGRAM, который при выполнении устанавливает режим вывода (по умолчанию 2 -
"Только на АЦПУ-128"), связывает внешние файлы и передаёт управление модулю с именем
Идентификатор-программы.

Если указан знак +, в генерируемый модуль PROGRAM вставляется экстракод конца задачи
62(8), что удобно при работе с отладчиком ОС ДИСПАК.

<Раздел-генерации-вектора-констант> ::=
        T <Идентификатор-программы> <Идентификатор-текстовой-константы>...


Следующие две карты:

*CALL PASHELP
T EXCLUDE AAA PPPP 00000 //2/ СТНФ .

эквивалентны вызову транслятора с языка МАДЛЕН и трансляции следующих восьми карт:
*ASSEMBLER
EXCLUDE: ,NAME,
         ,TEXT,8HAAA
         ,TEXT,8HPPPP
         ,TEXT,8H00000
         ,TEXT,8H//2/
         ,TEXT,8HCTH*
         ,OCT,
         ,END,

<Раздел-уборки-стандартных-имён> ::= У

В этом случае из временного каталога библиотеки исключаются все имена, начинающиеся
с символов P/ и PAS .

<Раздел-настройки-буферных-листов-и-трактов> ::=
        D <Восьмеричное-число-буферных-листов>
        <Восьмеричное-число-буферных-трактов>
        <Восьмеричное-число-обмена-для-начального-тракта>

При работе с последовательными файлами языка паскаль-монитор необходимо указывать
общее количество буферных листов для обмена, а также информацию о выделяемых
рабочих барабанах.

По умолчанию установлен режим
        D 2B 20B 250000B .

<Раздел-связывания-файлов> ::= F <Связывание-файлов> ...

Данный раздел генерирует модуль P/BEXF, в котором находится таблица, связывающая
внешние файлы. По умолчанию
        F *INPUT* 50 *OUTPUT* 51 PASINPUT 50 *RESULT* 20270000B.

Необходимый модуль P/BEXF можно запомнить в личной библиотеке.

Приведём теперь пример использования сервисного языка.

*NAME TTT
*PERSO:67640
*CALL *PASCAL
(*      НАСТРОЙКА НА БИБЛИОТЕКУ ПАСКАЛЯ *)
        PROGRAM ONE(OUTPUT, F);
        VAR
                L: CHAR;
                F: TEXT;
        BEGIN
                L := CHR(12B);
                REWRITE(F);
                WRITE(F, 'PROGRAM TWO (OUTPUT); ', L, 'BEGIN WRITELN(777) END.')
        END.
*CALL PASHELP
R ONE *F* 1270000 .
*CALL PROGRAM
*   ПРЕДЫДУЩАЯ КАРТА ЗАПИШЕТ НА БАРАБАН 278 ТЕКСТ
*  ПАСКАЛЬ-ПРОГРАММЫ, ПЕЧАТАЮЩЕЙ 777.
*CALL PASHELP
P 2 1000B 1270000B
*CALL *PASCAL
*   ТЕПЕРЬ КОМПИЛИРУЕМ ТЕКСТ, ЗАПИСАННЫЙ НА МБ 27
*CALL TWO
*   ПРОГРАММА TWO НАПЕЧАТАЕТ 777
*CALL PASHELP
T LIBPUNCH TWO ONE .
*LIBPUNCH
*   ЭТИ ТРИ КАРТЫ ВЫВЕДУТ МОДУЛИ TWO И ONE НА П/К В ВИДЕ СТАНДАРТНОГО МАССИВА
*CALL PASHELP
T EXCLUDE ONE .
*EXCLUDE
*   УБРАЛИ ИЗ ВРЕМЕННОЙ БИБЛИОТЕКИ МОДУЛЬ ONE
*CALL PASHELP
У   .
*   УБРАЛИ ИЗ ВРЕМЕННОЙ БИБЛИОТЕКИ ПОЧТИ ВСЕ СИСТЕМНЫЕ МОДУЛИ БИБЛИОТЕКИ ПАСКАЛЬ
*TO PERSO:27000,4
*   ЗАПОЛНИЛИ ВРЕМЕННУЮ БИБЛИОТЕКУ МОДУЛЕМ TWO НА БАРАБАНЕ 27(8)
*END FILE

2.4. Организация диалога.

Вывод.

При заполнении буфера ввода файла OUTPUT 51 (всего 126 символов) или при выполнении
оператора WRITELN(OUTPUT) начинается процедура вывода буфера файла на выводные
устройства. При этом файл дополняется одним значением из общей переменной PASENDS*,
в которой записан символ перевода строки CHR(12B).

Символ CHR(0), выводимый в файле, служит концом выводимой информации на видеотон
в коде видеотона.

Например, два оператора
        WRITELN('19', CHR(0));
        WRITELN('78', 'YEAR');
напечатают на видеотоне (но не на АЦПУ-128) одну строку
        1978YEAR

Для вывода вызывается подпрограмма P/PRINT, при этом начальный и конечный адреса
выводимой информации указываются 10 и 11 индекс-регистрами. Подпрограмма P/PRINT
выводит информацию на видеотон или АЦПУ-128 в зависимости от разрядов общей
переменной RGEXPORT.

Единичка первого разряда (справа) "включает" выдачу на видеотон, второго -
на АЦПУ-128.

При работе с видеотоном при первой выдаче информации на видеотон производится
"приём с приглашением" WHAT= в коде АЦПУ-128, на который пользователь может
ответить следующее:

E     - CALL PULT /* Дописано карандашом */
D     - T&*PASDDS*:=1B /* Дописано карандашом */
ETX   - "пустая посылка", никакого изменения в счёт;
K ETX - выполнение экстракода конца задачи 74(8);
А ETX - выдачу производить только на АЦПУ-128, счёт;
P ETX - выдачу производить только на видеотон и на АЦПУ-128, счёт;
T ETX - выдачу производить только на видеотон, счёт;
LN ETX - унетренней переменной N, определяющей, через сколько строк выдачи делать
"приём с приглашением" WHAT=, присваивается значение ORD(N), счёт; по умолчанию N=8;
После ответа L0 ETX управляющий приём с приглашением производиться не будет.

/* зачёркнуто "другой ответ", вместо этого дописано "S" */
S вызовет выполнение 62(8) экстракода конца задачи, вслед за которым следует
команда выдачи только на видеотон.

Подпрограмма P/PRINT принадлежит модулю PASOUT, который начинается с команд:
PASOUT :,NAME,
        ,STI,11
        ,STI,10
P/PRINT ,ENTRY,
 . . . . . .

Ввод.

Для ввода информации с видеотона можно использовать три внешние процедуры, которые
объявляются в программе следующим образом:

        PROCEDURE PASBIND(VAR X: TEXT); EXTERNAL;
        PROCEDURE PASADD (VAR X: TEXT); EXTERNAL;
        PROCEDURE PASINP (VAR A, B: ALFA); FORTRAN;

Оператор PASBINF(F) обнулит файл F, используя стандартную процедуру REWRITE(F),
откроет приём с видеотона в коде видеотона и запишет введённые символы в файл F.

Оператор PASADD(F) добавит к файлу F информацию, введённую с видеотона.

Оператор PASINT(A[1],A[7]) введён с видеотона информацию в массив A.

Обратим внимание на то, что все управляющие символы видеотона не редактируют
информацию при вводе, а вводятся наряду с обычными символами, а также на различие
в кодировке сходных по написанию символов, набранных на верхнем и нижнем регистре.
Исключением является символ ERASE, который отменяет введённую ранее информацию.

2.5. Совместное исполнение модулей.

Приведём пример совместного исполнения модулей паскаль-программы, внешних
паскаль-процедур и фортран-программы.

*NAME COMP
*PERSO:67640
        SUBROUTINE POWX(X, Y, Z)
                X = Y**Z
                RETURN
        END
*  ТЕПЕРЬ ТРАНСЛИРУЕМ ПАСКАЛЬ-ПРОГРАММЫ
*CALL *PASCAL
PROGRAM NOPROG (OUTPUT);
(*=E+ *)
PROCEDURE NULL (VAR X: REAL);
BEGIN
        X := 0;
END;

FUNCTION LENGTH (X, YY: REAL): REAL;
BEGIN
        LENGTH := SQR(X) + SQR(Y)
END;
BEGIN

END.
*  ТРАНСЛИРУЕМ ТЕПЕРЬ ВЕДУЩУЮ ПАСКАЛЬ-ПРОГРАММУ
*CALL *PASCAL
PROGRAM M (OUTPUT);
VAR
        A, B, C: REAL;

PROCEDURE POWX (VAR T, P, S: REAL); FORTRAN;
PROCEDURE NULL (VAR X: REAL); EXTERNAL;
FUNCTION LENGTH (X, YY: REAL): REAL; EXTERNAL;

BEGIN
        WRITELN(A, B, C);
        POWX(A, B, C);
        WRITELN(A, B, C);
        NULL(A);
        WRITELN(A);
        WRITELN(LENGTH(B, C))
END.DATA
        A:=2.0;
        B:=3.0;
        C:=4.0;
END
*EXECUTE
*END FILE

В вышеприведённом заднии вначале будут оттранслированы фортран-подпрограмма и две
паскаль-программы, а затем карта *EXECUTE вызовет программу М, которая быдет
выполняться.

При загрузке программы переменным A, B, C ьудут присвоены значения 2, 3, 4
соответственно, которые и напечатаются первым оператором вывода.

Далее оператор POWX(A, B, C) передаёт управление фортран-подпрограмме, которая
присвоит переменной А значение 81.0.

Оператор NULL(A) вызовет внешнюю паскаль-процедуру NULL, которая присвоит
переменной А нулевое значение.

В последнем операторе происходит обращение к внешней паскаль-функции, которая
возвращает значение К длины вектора. /* Не длины вектора, судя по коду,
а квадрата длины */

Внимание: паскаль-программа не должна вызывать другие паскаль-программы.

2.6. Утилиты для системы Паскаль-Монитор.

В данном разделе приводится описание некоторых модулей системной паскаль-библиотеки.

Сарвисный модуль PASHELPописан в разделе 2.3.

TIME. Программа PASTIME содержит процедуру-точку-входа TIME, к которой можно
обращаться из любой паскаль-программы. Из мониторной системы (директивой *CALL)
необходимо обращаться к программе PASTIME.

При обращении печатается
        RUNT=<Фремя-процессора> . REST=<Оставшееся-время>.
        DIFF=<Время-прошедшее-после-предыдущего-вызова>

Кроме того, в общей переменной под именем TIMEOLD типа REAL запоминается
время-процессора.

Данную процедуру удобно использовать при определении скорости выполнения конструкций
языков мониторной системы.

PULT. Если мониторная система вызывается из системы Пульт, то при обращении
ко внешней процедуре PULT управление будет передано системе Пульт.

PASTPR. Внешняя паскаль-процедура с одним параметром предназначена для печати
слов в кодировке TEXT-ДУБНА. Вызову данной процедуры должен предшествовать какой-либо
оператор записи в соответствующий файл.

Пример использования:

PROCEDURE PASTPR (A: ALFA); EXTERNAL;
WRITE(X, ' '); PASTPR(ALL);

PASOUT. Внешняя Фортран-процедура с двумя параметрами предназначена для вывода
информации от адреса первого параметра до адреса второго параметра.

Пример использования:

VAR
        I: INTEGER;
        M: ARRAY 1..100 OF ALFA;
PROCEDURE PASOUT(VAR A, A1: ALFA); FORTRAN;
. . . . . . . . . . . . . . . . . . . . . . .
FOR I TO 100 DO
        READLN(M[I]);
PASOUT(M[1], M[100]);

PASLIST. Внешняя функция без параметров. Анализирует режим печати, установленный
в мониторной системе "Дубна", возвращает значения 0, 1 или 2, соответствующие
режимам
   *NO LIST    *STANDARD LIST    *FULL LIST
PASBIND, PASADD, PASINP.

Процелуры ввода информации с видеотона, см. разд. 2.4. "Организация диалога".

PASGOST7. Работая в системе Пульт, можно запускать паскаль-компилятор, генерируя
задачу (обычную или подчинённую), либо непосредственно в решаемой задаче с
помощью приказа вида
        ДАЙ ФОРТ ИМЯ-МАССИВА-С-ЗАДАНИЕМ [Г:А]

Если в задании используется режим полной памяти, устанавливаемый картой
*CALL FICMEMOR, то указание литеры F в конце приказа обязательно.

Примеры заданий разобраны в разд. 2.1, 2.2 и 2.3.

Если программа содержит строки более 80 символов или программа достаточно большая
(данный запуск более эффективно "читает" текст), то удобнее загружать текст исходной
программы в кодировке АЦПУ-128 на барабан 27(8) (массив БУФ системы Пульт), а далее
использовать, например, следующее задание:

*NAME TRANSLATION FROM 27
*PERSO:67640
*CALL PASGOST7
*CALL FICMEMOR
*CALL PASHELP
P  2  0  20270000B .
*CALL *PASCAL
*EXECUTE
*END FILE

Третий приказ производит необходимую перекодировку, т.е. модуль PASGOST7
перекодирует текст, записанный на барабане 27(8), из кодировки АЦПУ-128 в кодировку
ISO ДУБНА.

Примеры.

1) Следующие три программы обрабатывают стандартный вводной файл вплоть до карты /*,
которая используется для обозначения конца текстового файла.

Программы PASFOR и TOPULT генерируют выходной текст в файле RESULT, по умолчанию
определённом на барабане 27(8) с нулевого тракта, с помощью режимов R и F
(см. прил. 1) сервисной программы PASHELP можно настроить выходной файл на требуемое
устройство.

PASFOR.
Программа предназначена для автоматического редактирования паскаль-программ
для получения структурно расположенного текста ("красивая распечатка"). Управляющий
комментарий (*/F3*) автоматически преобразует короткие _( и _) в стандартные BEGIN
и END. Комментарий (*/F4*) отменяет действие (*/F3*). Количество значащих позиций
исходного текста определяется в соответствии с управляющимрежимом U. Выходной текст,
представленный в стандартном для редактора мониторной системы "Дубна" виде, состоит
из карт:

*CALL *PASCAL
Преобразованный текст паскаль-программы
*READ OLD

В позиции с 73 по 80 записываются пробелы.

Программа PASFOR переделана в ВЦ АН СССР учёными из ГДР.

XREF.
Программа "Перекрёстные ссылки" обрабатывает текст паскаль-программы и печатает
лексически упорядоченную таблицу, каждая строка которой содержит шестизнаковый
идентификатор и номера строк, где встречается данный идентификатор.

Программа XREF переделана в ВЦ АН СССР учёными из ГДР.

TOPULT.
Программа перекодирует стандартный вводной файл в файл RESULT из кодировки ISO-Дубна
в массив системы Пульт /БРЯ 72/, выбрасывая при этом позиции с 73 по 80
и заключительные пробелы.

Следующий пример иллюстрирует применение рассмотенных программ.
*NAME THREE RUNS
*PERSO:67640
*CALL PASFOR
PROGRAM TPAP (OUTPUT);
BEGIN
        IF 5=7 THEN BEGIN
                WRITELN(' SCHLECHT')
        END ELSE
                WRITELN(' GOOD')
END.
/*
*READ TAPE 27000
* Оттранслировали преобразованную TPAP, теперь выполним TPAP и с помощью редактора
  и программы TOPULT запишем преобразованный текст для системы Пульт.
*CALL TPAP
*EDIT
*W
*(((
*CALL TOPULT
*)))
*R:27000
*R OUT
/*
*EE
*READ DRUM
*CALL XREF
PROGRAM  T (OUTPUT);
BEGIN END.
/*
*END FILE

2) Перекодировка
   A) ISO --> GOST, ISO --> TEXT
PROGRAM ..... (..., ISOPGOST, ISOPTEXT);
PROCEDURE PASISOCD; EXTERNAL;
VAR C, S: CHAR;
        ISOPGOST: PACKED ARRAY ['0' .. ' '] OF CHAR;
        ISOPTEXT: PACKED ARRAY ['0' .. 'Ч'] OF CHAR;
BEGIN
        PASISOCD;
        C := '5'; (* КОД ISO *)
        S := ISOPGOST[C];
        WRITELN(S OCT); (* КОД GOST *)
        WRITELN(ISOPTEXT[C] OCT); (* КОД TEXT *)
END.

Б) Общая область
        ISOPITM:,LC, 22
может быть использована для дополнительной кодировки.

Заключение.

В данной работе рассмотрено описание особенностей языка Паскаль-Монитор по сравнению
со стандартной версией, определённой в /JEN 74/. Почти точное описание стандартного
языка (фактически различие только в заголовке программы) опубликовано на русском
языке в /ВИР 77/.

В приложении обсуждаются расширения сервисного языка и управляющие режимы компилятора,
введённые в конце данной работы.

В заключение мне хочется поблагодарить за полезные советы, проявленный интерес
к работе и активное использование системы Л.М.Эльберта, В.М.Курочкина, А.Б.Ходулева,
М.В.Паремского, Д.Карла, Р.Хирра, А.Мюллера, В.А.Серебрякова, А.Н.Бирюкова,
В.И.Скрипниченко, С.Покровского; а также В.И.Филиппова за исчерпывающую информацию
о реализуемой им системе по обработке и хранению информации.

Список литературы.

1. /ВИР 77/ Н.Вирт. Язык программирования Паскаль (пересмотренное сообщение).
Пер. с англ. С.Б. Покровского. Алгоритмы и организация решения экономических задач.
Вып. 9, М. "Статистика", 1977.

2. /ВОЛ 69/ А.И.Волков. Автокод МАДЛЕН. ОИЯИ б4-11-4654, Дубна, 1969.

3. /ДАЛ 75/ У.Дал, Э.Дейкстра, К.Хоор. Структурное программирование.
М., "Мир", 1975.

4. /ПИР 78/ С.И.Пирин. О реализации компилятора Паскаль на ЭВМ БЭСМ-6.
В СБ.: "Обработка символьной информации", вып. 4, М., ВЦ АН СССР, 1978.

5. /ФИЛ / В.И.Филиппов, И.В.Величко. Архивная система МАРС-6 и её интерфейсы.
Обработка символьной информации N5, в печати.

6. /ЩУС 74/ Б.Щустер. Паскал-Б. Версия 3.0. Справочник.
Научно-исследовательский центр Братиславы, 1974.

7. /JEN 74/ K.Jensen, N.Wirth. Pascal User Manual and Report, Lecture Notes in
Computer Science, vol. 18, Springer-Verlag, New-York, 1974.

8. /RIC 76/ G.Richmond. "Pascal Newsletter, No. 3"? Sigplan Notices, 2, 2, 1976.

Дополнение. Руководство системного программиста.

Данное описание корректно для версий от 13. (7.6.79)
Библиотека от 21.06.79.

1. Новые возможности. Управляющий комментарий (*=F+*), стоящий перед описанием
фортран-подпрограмм/функций, блокирует проверку числа, типа и вида параметров
при обращении к соответствующей подпрограмме/функции.

При этом все параметры передаются по ссылке, как это принято в фортране.

Не рекомендуется использовать выражения!!

Например.

(*=F+*) PROCEDURE LOADGO(I:INTEGER); FORTRAN;

(* Это описание процедуры с различным числом параметров. После описания
   фортран-процедуры автоматически включается режим F-.
   Далее приведены обращения к этой процедуре *)

. . . . . . . . . . . . . . . . . . . .

LOADGO('EX6700');
LOADGO('A ');
(* 'A' *)
LOADGO(X, Z, 'TWOPAR');
LOADGO(1, 2, 3, 'THREE');
LOADGO(1, 2, 3, 4, 'FIER');

2. Если нет вызова описанных внешних и фортран процедур/функций, то они
не загружаются загрузчиком.

3. В режиме (*=T+*) при разыменовывании указателя производится проверка корректности
значения для глобальных данных. При некорректном значении печатается диагностика,
например:
        749 LINE POINTER OVERRANGE
За которой следует обращение к подпрограмме HALT.

При использовании стандартных функций PTR или REF следует в режиме (*=T+*) добавлять
режим (*=S7*), который блокирует указанную проверку.

4. Можно считывать и записывать в файлы неупакованные символьные массивы (раньше
обязательно требовались упакованные массивы).

Например, чтобы распечатать карты с номерами впереди, можно использовать следующую
программу.

PROGRAM PRINTNUM(OUTPUT,INPUT);
VAR
        NUM: ARRAY [1 .. 8] OF CHAR;
        CONT: ARRAY [1 .. 72] OF CHAR;
BEGIN
        WHILE NOT EOF(INPUT) DO BEGIN
                READLN(CONT, NUM);
                WRITELN(' ', NUM, ' ', CONT)
        END
END.

Работа с архивной системой МАРС.

1. Стандартная процедура NEWD реализована.

2. Стандартная процедура MODD модифицирует информацию, если она есть, иначе
записывает, т.е. работает как PUTD.

3. Для заведения специальной области "КОБЛА", содержащей каталог остальных областей,
используется фортран-процедура PASACD. Например, если необходимо завести каталог
на направлении 52(8) с 0 зоны длиной в одну зону, выполняем следующую программу.

PROGRAM SETCOBLA (OUTPUT);
(*=F+*) PROCEDURE PASACD (VAR I:INTEGER); FORTRAN;
BEGIN
        PASACD(1520000B)
END.

4. Настройка каталога областей (КОБЛЫ).

Информация о расположении КОБЛЫ в виде MMMMZZNNNNB находится в 4 ячейке системного
листа, распределяемого командой
        P/BDSYS;,PC,1024

Для настройки КОБЛЫ используем внешнюю процедуру PASSETAR "SET UP AREA".
Например, чтобы настроить заведённую в предыдущем разделе КОБЛУ, можно выполнить

PROGRAM T(OUTPUT);
PROCEDURE PASSETAR (VAR I:INTEGER); EXTERNAL;
BEGIN PASSETAR (1520000B) END.

6. Выполнение произвольной МАРС команды.

а) Необходимые описания
        PROCEDURE PASBDI; EXTERNAL;
        PROCEDURE PASBD; EXTERNAL;
        ПЕРЕМЕННА_УКАЗАТЕЛЬ НА ВЕКТОР BDV ( ОБЩАЯ );
б) Для исполнения МАРС команды необходимо:
   - выполнить хотя бы раз PASBDI,
   - используя переменную BDV, заслать параметры,
   - выполнить PASBD.

7. Некоторые полезные общие переменные.

P/BDSYS;,PC,1024 - лист для кодов системы МАРС;
P/BDBUF;,PC,1024
P/BDTAB;,PC,1024 - листы для буферов системы МАРС;

*ERSTOP*:,LC,1 - при ошибке, если *ERSTOP*=,LOG,0; (по умолчению), будет продолжено
вычисление, предварительно обратившись по умолчанию к пустой программе PASBDE;

*BDVECT*:,LC,250B - память для вектора; после выполнения PASBDI переменная *BDV*
начинает указывать на *BDVECT*, и в *BDVECT* занесена информация о буферных листах,
о реакции на ошибку и др.;

*BDV*:,LC,1 - указывает на текущий вектор МАРСа; см. также *BDVECT*.

* * *
